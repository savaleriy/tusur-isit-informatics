# Python

### Работа с модулями: создание, подключение инструкциями import и from
Модулем в Python называется любой файл с программой (да-да, все те программы, которые вы писали, можно назвать модулями). В этой статье мы поговорим о том, как создать модуль, и как подключить модуль, из [стандартной библиотеки](https://pythonworld.ru/moduli) или написанный вами.

Каждая программа может импортировать модуль и получить доступ к его классам, функциям и объектам. Нужно заметить, что модуль может быть написан не только на Python, а например, на C или C++.

#### Подключение модуля из стандартной библиотеки

Подключить модуль можно с помощью инструкции import. К примеру, подключим [модуль os](https://pythonworld.ru/moduli/modul-os.html) для получения текущей директории:

```python
import os
 os.getcwd()
'C:\\Python33'
```

После ключевого слова **import** указывается название модуля. Одной инструкцией можно подключить несколько модулей, хотя этого не рекомендуется делать, так как это снижает читаемость кода. Импортируем модули [time](https://pythonworld.ru/moduli/modul-time.html) и [random](https://pythonworld.ru/moduli/modul-random.html).
```python
import time, random
time.time()
1376047104.056417
random.random()
0.9874550833306869
```

После импортирования модуля его название становится переменной, через которую можно получить доступ к атрибутам модуля. Например, можно обратиться к константе e, расположенной в модуле [math](https://pythonworld.ru/moduli/modul-math.html):

```python
import math
math.e
2.718281828459045
```


Стоит отметить, что если указанный атрибут модуля не будет найден, возбудится [исключение](https://pythonworld.ru/tipy-dannyx-v-python/isklyucheniya-v-python-konstrukciya-try-except-dlya-obrabotki-isklyuchenij.html) AttributeError. А если не удастся найти модуль для импортирования, то ImportError.

```python
>>> import notexist
Traceback (most recent call last):
  File "", line 1, in
    import notexist
ImportError: No module named 'notexist'
>>> import math
>>> math.Ё
Traceback (most recent call last):
  File "", line 1, in
    math.Ё
AttributeError: 'module' object has no attribute 'Ё'
```

#### Использование псевдонимов

Если название модуля слишком длинное, или оно вам не нравится по каким-то другим причинам, то для него можно создать псевдоним, с помощью ключевого слова as.

```python>>> 
import math as m
>>> m.e
2.718281828459045
```
Теперь доступ ко всем атрибутам модуля math осуществляется только с помощью переменной m, а переменной math в этой программе уже не будет (если, конечно, вы после этого не напишете import math, тогда модуль будет доступен как под именем m, так и под именем math).

#### Инструкция from

Подключить определенные атрибуты модуля можно с помощью инструкции from. Она имеет несколько форматов:
```python
from <Название модуля> import <Атрибут 1> [ as <Псевдоним 1> ], [<Атрибут 2> [ as <Псевдоним 2> ] ...]
from <Название модуля> import *
```


Первый формат позволяет подключить из модуля только указанные вами атрибуты. Для длинных имен также можно назначить псевдоним, указав его после ключевого слова as.

```python
>>> from math import e, ceil as c
>>> e
2.718281828459045
>>> c(4.6)
5
```

Импортируемые атрибуты можно разместить на нескольких строках, если их много, для лучшей читаемости кода:

```python
>>> from math import (sin, cos,
...           tan, atan)
```

Второй формат инструкции from позволяет подключить все (точнее, почти все) переменные из модуля. Для примера импортируем все атрибуты из модуля [sys](https://pythonworld.ru/moduli/modul-sys.html):

```python
>>> from sys import *
>>> version
'3.3.2 (v3.3.2:d047928ae3f6, May 16 2013, 00:03:43) [MSC v.1600 32 bit (Intel)]'
>>> version_info
sys.version_info(major=3, minor=3, micro=2, releaselevel='final', serial=0)
```

Следует заметить, что не все атрибуты будут импортированы. Если в модуле определена переменная __all__ (список атрибутов, которые могут быть подключены), то будут подключены только атрибуты из этого списка. Если переменная __all__ не определена, то будут подключены все атрибуты, не начинающиеся с нижнего подчёркивания. Кроме того, необходимо учитывать, что импортирование всех атрибутов из модуля может нарушить пространство имен главной программы, так как переменные, имеющие одинаковые имена, будут перезаписаны.

#### Создание своего модуля на Python

Теперь пришло время создать свой модуль. Создадим файл mymodule.py, в которой определим какие-нибудь функции:
```python
def hello():
    print('Hello, world!')

def fib(n):
    a = b = 1
    for i in range(n - 2):
        a, b = b, a + b
    return b
```

```
# Pseudo FileSystem
--- mymodule.py
--- main.py
```

Теперь в этой же папке создадим другой файл, например, main.py:

```python
import mymodule

mymodule.hello()
print(mymodule.fib(10))
```

Выведет:
```python
Hello, world!
55
```

Поздравляю! Вы **сделали свой модуль**! Напоследок отвечу ещё на пару вопросов, связанных с созданием модулей:

### Как назвать модуль?

Помните, что вы (или другие люди) будут его импортировать и использовать в качестве переменной. Модуль нельзя именовать также, как и ключевое слово (их список можно посмотреть [тут](https://pythonworld.ru/osnovy/klyuchevye-slova-modul-keyword.html)). Также имена модулей нельзя начинать с цифры. И не стоит называть модуль также, как какую-либо из [встроенных функций](https://pythonworld.ru/osnovy/vstroennye-funkcii.html). То есть, конечно, можно, но это создаст большие неудобства при его последующем использовании.

### Куда поместить модуль?

Туда, где его потом можно будет найти. Пути поиска модулей указаны в переменной `sys.path`. В него включены текущая директория (то есть модуль можно оставить в папке с основной программой), а также директории, в которых установлен python. Кроме того, переменную `sys.path` можно изменять вручную, что позволяет положить модуль в любое удобное для вас место (главное, не забыть в главной программе модифицировать `sys.path`).

### Можно ли использовать модуль как самостоятельную программу?

Можно. Однако надо помнить, что при импортировании модуля его код выполняется полностью, то есть, если программа что-то печатает, то при её импортировании это будет напечатано. Этого можно избежать, если проверять, запущен ли скрипт как программа, или импортирован. Это можно сделать с помощью переменной `__name__`, которая определена в любой программе, и равна `__main__`, если скрипт запущен в качестве главной программы, и имя, если он импортирован. Например, mymodule.py может выглядеть вот так:
```python
def hello():
    print('Hello, world!')

def fib(n):
    a = b = 1
    for i in range(n - 2):
        a, b = b, a + b
    return b

if __name__ == "__main__":
    hello()
    for i in range(10):
        print(fib(i))
```
### Инструкция assert
Инструкции assert в Python — это булевы выражения, которые проверяют, является ли условие истинным (`True`). Они определяют факты (утверждения) в программе. Assertion — это проверка, которую можно включить, а затем выключить, завершив тестирование программы.

Возьмем простой пример функции деления. Можно быть уверенным в том, что делитель не должен быть нолем. Это и указывается при тестировании. Разберем этот пример позже.

#### Что такое Assertion (утверждение)

Assertions (утверждения) — это инструкции, которые «утверждают» определенный кейс в программе. В Python они выступают булевыми выражениями, которые проверяют, является ли условие истинным или ложным. Если оно истинно, то программа ничего не делает и переходит к выполнению следующей строчки кода.

Но если оно ложно, то программа останавливается и возвращает ошибку.

Следующий синтаксис — это базовая структура инструкций утверждения в Python.

```
assert condition
```

Если же нужно добавить сообщение для вывода при ложном условии, то синтаксис будет таким.

```
assert condition, message
```

Это сообщение позволит лучше понять, почему код не сработал.
```python
def avg(ranks):
    assert len(ranks) != 0
    return round(sum(ranks)/len(ranks), 2)

ranks = [62, 65, 75]
print("Среднее значение:", avg(ranks))
```
В этом примере нужно, чтобы пользователь не оставлял параметры пустыми. Если этого не сделать, вернется ошибка `Assertion Error`. Вот пример вывода:

```
Среднее значение: 67.33
```

В этом случае параметры были переданы, поэтому функция вернула нужный результат.

Теперь попробуем ничего не передавать.

```python

def avg(ranks):
    assert len(ranks) != 0
    return round(sum(ranks)/len(ranks), 2)

ranks = []
print("Среднее значение:", avg(ranks))
```

Длина массива `ranks` оказалась 0, и python вернул ошибку `Assertion Error`.

```
Traceback (most recent call last):
  File "C:/Users/asd/AppData/Local/Programs/Python/Python38/wb.py", line 6, in <module>
    print("Среднее значение:", avg(ranks))
  File "C:/Users/asd/AppData/Local/Programs/Python/Python38/wb.py", line 2, in avg
    assert len(ranks) != 0
AssertionError
```

Исключения `Assertion Error` можно перехватывать и обрабатывать как и любые другие исключения с помощью try-except. Но если их обработать неправильно, то программа остановится и вернет `traceback`.

Однако в примере выше она не возвращает ошибку с нужным сообщением. Ее можно написать самостоятельно. Вот как это делается.


```python

def avg(ranks):
    assert len(ranks) != 0, 'Список ranks не должен быть пустым'
    return round(sum(ranks)/len(ranks), 2)

ranks = []
print("Среднее значение:", avg(ranks))
```

Вторым аргументом к `assert` в примере выше было передано сообщение, которое позже появится в выводе.

```
Traceback (most recent call last):
  File "C:/Users/asd/AppData/Local/Programs/Python/Python38/wb.py", line 6, in <module>
    print("Среднее значение:", avg(ranks))
  File "C:/Users/asd/AppData/Local/Programs/Python/Python38/wb.py", line 2, in avg
    assert len(ranks) != 0, 'Список ranks не должен быть пустым'
AssertionError: Список ranks не должен быть пустым
```

#### Assert с сообщением об ошибки

Рассмотрим еще один пример с делением на 0.

```python

def divide(x, y):
    assert y != 0 , 'Нельзя делить на 0'
    return round(x/y, 2)

z = divide(21,3)
print(z)

a = divide(21,0)
print(a)
```

В этом примере, если делителем будет ноль, то `assert` вернет сообщение с ошибкой. Посмотрим на вывод.

```
7.0
Traceback (most recent call last):
  File "C:/Users/asd/AppData/Local/Programs/Python/Python38/wb.py", line 8, in <module>
    a = divide(21,0)
  File "C:/Users/asd/AppData/Local/Programs/Python/Python38/wb.py", line 2, in divide
    assert y != 0 , 'Нельзя делить на 0'
AssertionError: Нельзя делить на 0
```

На третьей сверху строчке написана сама инструкция `assert`. Именно здесь проверяется, не является ли переменная `y` равной 0. Если она больше 0, то условие истинно, и код возвращает требуемый результат.

Но если вызвать метод `division()` со вторым аргументом 0, то условие `assert` будет ложным.

По этой причине и возникает исключение `Assertion Error`. Именно оно возвращает ошибку с сообщением «Нельзя делить на 0».

#### Методы assert

| Метод                      | Проверка на         | Работает с |
| -------------------------- | ------------------- | ---------- |
| `assertEqual(x, y)`        | x == y              |            |
| `assertNotEqual(x, y)`     | x != y              |            |
| `assertTrue(x)`            | bool(x) равно True  |            |
| `assertFalse(x)`           | bool(x) равно False |            |
| `assertIs(x, y)`           | x это y             | 3.1        |
| `assertIsNot(x, y)`        | x это не y          | 3.1        |
| `assertIsNone(x)`          | x это None          | 3.1        |
| `assertIsNotNone(x)`       | x это не None       | 3.1        |
| `assertIn(x, y)`           | x в y               | 3.1        |
| `assertNotIn(x, y)`        | x не в y            | 3.1        |
| `assertIsInstance(x, y)`   | isinstance(x, y)    | 3.2        |
| `assertNotIsInstance(x,y)` | не isinstance(x, y) | 3.2        |

#### Как проверить, что функция возвращает исключение

Можно использовать `TestCase.assertRaises` (или `TestCase.failUnlessRaises`) из модуля `unittest`.

```python

import unittest

def broken_function():
    raise Exception('Это ошибка')

class MyTestCase(unittest.TestCase):
    def test(self):
        with self.assertRaises(Exception) as context:
            broken_function()

        self.assertTrue('Это ошибка' in str(context.exception))

if __name__ == '__main__':
    unittest.main()
```

Вывод:

```
.
----------------------------------------------------------------------
Ran 1 test in 0.051s

OK
```

## `list`
### Инициализация и индексация списков

Python предоставляет упорядоченные структуры данных для хранения объектов — списки (list). В отличие от массивов в других языках, списки в Python могут содержать объекты различных типов.

Список создается с помощью квадратных скобок `[]`:
```python
list1 = [1, 'two', 3.14, 0]
list2 = [2, 4, -0.1, list1, True]
```

Списки могут содержать ссылки на различные типы данных, включая другие списки. Их размер не нужно объявлять заранее. Например, пустой список можно создать так:
```python
list0 = []
```

Элементы извлекаются по индексу (индексация начинается с 0):
```python
list1[2]  # 3.14
list2[-1]  # True
list2[3][1]  # 'two'
```

В последнем примере извлекается второй элемент из четвертого элемента 
списка `list2`, который также является списком.

Элементы списков могут быть индексированы. Например:

```python
list2[3][1]  # 'two'
list2[3][1][1]  # 'w'
```

Для проверки наличия элемента в списке используется оператор `in`, но он не рекурсивен:

```python
1 in list1  # True
'two' in list2  # False
```

Второе выражение возвращает `False`, потому что `list2` не содержит строку `'two'` напрямую.

### Изменяемость списков


При копировании списка важно помнить, что присваивание переменной другой список не создает его копию:

```python
q1 = [1, 2, 3]
q2 = q1
q1[2] = 'oops'
print(q1)  # Вывод: [1, 2, 'oops']
print(q2)  # Вывод: [1, 2, 'oops']
```

В этом примере `q1` и `q2` ссылаются на один и тот же список, поэтому изменения в одном списке отражаются в другом.

В Python можно вырезать (slice) элементы из списков так же, как и из строк. Например:

```python
q1 = [0., 0.1, 0.2, 0.3, 0.4, 0.5]
print(q1[1:4])   # Вывод: [0.1, 0.2, 0.3]
print(q1[::-1])  # Вывод: [0.5, 0.4, 0.3, 0.2, 0.1, 0.0]
print(q1[1::2])  # Вывод: [0.1, 0.3, 0.5]
```
Операция среза создает новый список. Например:

```python
q2 = q1[1:4]
q2[1] = 99
print(q2)  # Вывод: [0.1, 99, 0.3]
print(q1)  # Вывод: [0.0, 0.1, 0.2, 0.3, 0.4, 0.5]
```

### Методы list

В Python списки имеют множество полезных методов, позволяющих изменять их содержимое и размер. Вот некоторые из наиболее часто используемых методов:

| Метод                    | Описание                                            |
| ------------------------ | --------------------------------------------------- |
| `append(element)`        | Добавляет `element` в конец списка.                 |
| `extend(list2)`          | Расширяет список элементами из `list2`.             |
| `index(element)`         | Возвращает наименьший индекс, содержащий `element`. |
| `insert(index, element)` | Вставляет `element` по указанному `index`.          |
| `pop()`                  | Удаляет и возвращает последний элемент из списка.   |
| `remove(element)`        | Удаляет первое вхождение `element` из списка.       |
| `sort()`                 | Сортирует элементы списка.                          |
| `reverse()`              | Изменяет порядок элементов на обратный.             |
| `copy()`                 | Возвращает поверхностную копию списка.              |
| `count(element)`         | Возвращает количество вхождений `element` в списке. |
```python
q = []
q.append(4)
print(q)  # Вывод: [4]

q.extend([6, 7, 8])
print(q)  # Вывод: [4, 6, 7, 8]

q.insert(1, 5)  # Вставка 5 по индексу 1
print(q)  # Вывод: [4, 5, 6, 7, 8]

q.remove(7)
print(q)  # Вывод: [4, 5, 6, 8]

print(q.index(8))  # Вывод: 3 (элемент 8 находится по индексу 3)

# Sort and Reverse

q = [2, 0, 4, 3, 1]
q.sort()
print(q)  # Вывод: [0, 1, 2, 3, 4]

q.reverse()
print(q)  # Вывод: [4, 3, 2, 1, 0]
```

Если нужно получить отсортированную копию списка без изменения оригинала, можно использовать `sorted()`:
```python
q = ['a', 'e', 'A', 'c', 'b']
sorted_q = sorted(q)
print(sorted_q)  # Вывод: ['A', 'a', 'b', 'c', 'e']
print(q)         # Вывод: ['a', 'e', 'A', 'c', 'b'] (исходный список остается неизменным)
```
Для сортировки в убывающем порядке используется аргумент `reverse=True`:
```python
q = [10, 5, 5, 2, 6, 1, 67]
print(sorted(q, reverse=True))  # Вывод: [67, 10, 6, 5, 5, 2, 1]
```

## `tuple`

Кортежи (tuple) — это неизменяемые последовательности, которые можно воспринимать как списки. Кортеж создается с использованием круглых скобок:
```python
t = (1, 'two', 3.0)
print(t)  # Вывод: (1, 'two', 3.0)
```

Кортежи можно индексировать и вырезать, как списки, но нельзя изменять их содержимое (добавлять или удалять элементы):

```python
print(t[1])  # Вывод: 'two'
# t[2] = 4  # Это вызовет ошибку: TypeError
```

Хотя кортежи неизменяемы, они могут содержать изменяемые объекты, такие как списки:
```python
t = (1, ['a', 'b', 'd'], 0)
t[1][2] = 'c'  # Изменяем элемент внутри списка
print(t)  # Вывод: (1, ['a', 'b', 'c'], 0)
```

### Создание кортежей

Пустой кортеж создается с помощью пустых скобок:
```python
t0 = ()
```

Чтобы создать кортеж с одним элементом, нужно добавить запятую:
```python
t = ('one',)  # Это кортеж с одним элементом
```

### Упаковка и распаковка кортежей

Кортеж можно создать без круглых скобок:
```python
t = 1, 2, 3
print(t)  # Вывод: (1, 2, 3)
```

Это называется упаковкой кортежа. Распаковка происходит при присваивании значений нескольким переменным:

```python
a, b, c = 97, 98, 99
print(b)  # Вывод: 98
```

## Итерируемые объекты в Python

**Примеры итерируемых объектов**

Строки, списки и кортежи — это примеры итерируемых объектов, которые позволяют проходить по элементам по одному. Их можно преобразовывать в списки или кортежи с помощью конструктора `list()` или `tuple()`:

```python
# Преобразование строки в список
print(list('hello'))  # Вывод: ['h', 'e', 'l', 'l', 'o']

# Создание нового списка
a = [5, 4, 3, 2, 1]
b = list(a)  # Создаем новый объект списка
print(b is a)  # Вывод: False (разные объекты)
```

**Функции `any()` и `all()`**

Функция `any()` проверяет, есть ли хотя бы один элемент, равный `True`, а `all()` проверяет, все ли элементы равны `True`:

```python
a = [1, 0, 0, 2, 3]
print(any(a), all(a))  # Вывод: (True, False)

b = [[], False, 0.]
print(any(b), all(b))  # Вывод: (False, False)
```

### Синтаксис распаковки аргументов

Иногда нужно вызвать функцию с аргументами из списка или кортежа. Синтаксис `*` распаковывает последовательность в позиционные аргументы:

```python
import math
t = [3, 4]
# math.hypot(t)  # Это вызовет ошибку
result = math.hypot(*t)  # Правильный вызов с распаковкой
print(result)  # Вывод: 5.0

```

#### Упаковка значений

Вы можете использовать оператор `*`, чтобы упаковать значения из кортежа или списка:

```python
# Упаковка значений в одну переменную
*a, = 1, 2
print(a)  # Вывод: [1, 2]
```
Эта операция требует запятой в конце, чтобы указать, что левая сторона — это кортеж или список.

#### Примеры упаковки и распаковки
**Упаковка хвостовых значений:**
```python
a, *b = 1, 2, 3
print(a)  # Вывод: 1
print(b)  # Вывод: [2, 3]
```
**Упаковка начальных значений**:
```python
*a, b = 1, 2, 3
print(a)  # Вывод: [1, 2]
print(b)  # Вывод: 3
```
**Упаковка с обязательными переменными**:
```python
*a, b, c = 1, 2, 3
print(a)  # Вывод: [1]
print(b)  # Вывод: 2
print(c)  # Вывод: 3
```

**Ошибка при недостаточном количестве значений:**
```python
# Вызывает ValueError из-за недостаточного количества значений
# *a, b, c, d, e = 1, 2, 3
```

**Использование `*` с генераторами и диапазонами**
```python
gen = (2 ** x for x in range(10))
*g, = gen
print(g)  # Вывод: [1, 2, 4, 8, 16, 32, 64, 128, 256, 512]

ran = range(10)
*r, = ran
print(r)  # Вывод: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

**Параллельное присваивание**

```python
employee = ["John Doe", "40", "Software Engineer"]
name, age, job = employee
print(name)  # Вывод: 'John Doe'
print(age)   # Вывод: '40'
print(job)   # Вывод: 'Software Engineer'
```

**Обмен значениями**
```python
a = 100
b = 200
a, b = b, a
print(a)  # Вывод: 200
print(b)  # Вывод: 100
```

**Сбор нескольких значений**
```python
seq = [1, 2, 3, 4]
first, *body, last = seq
print(first)  # Вывод: 1
print(body)   # Вывод: [2, 3]
print(last)   # Вывод: 4
```

Этот подход более гибкий, так как адаптируется к изменениям в длине последовательности:

```python
seq = [1, 2, 3, 4, 5, 6]
first, *body, last = seq
print(body)  # Вывод: [2, 3, 4, 5]
```

**Игнорирование ненужных значений**

Вы можете использовать временную переменную (обычно `_`), чтобы игнорировать ненужные значения:

```python
a, b, *_ = 1, 2, 0, 0, 0, 0
print(a)  # Вывод: 1
print(b)  # Вывод: 2
print(_)  # Вывод: [0, 0, 0, 0]
```
### Циклы `for`

Циклы `for` позволяют последовательно перебирать элементы итерируемого объекта:

```python
fruit_list = ['apple', 'melon', 'banana', 'orange']
for fruit in fruit_list:
    print(fruit)
```

```
apple
melon
banana
orange
```

Циклы могут быть вложенными:

```python
for fruit in fruit_list:
    for letter in fruit:
        print(letter, end='.')
    print()  # Переход на новую строку
```

```python
a.p.p.l.e.
m.e.l.o.n.
b.a.n.a.n.a.
o.r.a.n.g.e.
```

## `zip`

Что делать, если нужно одновременно пройти по нескольким последовательностям? Для этого и предназначена встроенная функция `zip`. Она создает объект-итератор, в котором каждый элемент представляет собой кортеж из элементов, выбираемых поочередно из переданных последовательностей.
```python
a = [1, 2, 3, 4]
b = ['a', 'b', 'c', 'd']
```

При вызове `zip(a, b)` получается объект-итератор:

```python
zip(a, b)
# <builtins.zip at 0x104476998>
```

Теперь можно итерироваться по парам элементов:
```python
for pair in zip(a, b):
    print(pair)
#(1, 'a')
#(2, 'b')
#(3, 'c')
#(4, 'd')
```

#### Разделение последовательностей (unzip)

Функцию `zip` можно использовать и для разделения кортежей:
```python
z = zip(a, b)  # Соединение
A, B = zip(*z)  # Разделение
print(A, B)
# (1, 2, 3, 4) ('a', 'b', 'c', 'd')
```

Проверим, совпадают ли списки:
```python
list(A) == a, list(B) == b
# (True, True)
```