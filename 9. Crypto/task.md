
# 1. Шифр Цезаря

Разбейтесь на пары. Один из студентов пишет код шифрования Цезаря, а другой код брутфорса данного шифра.

Если сопоставить каждому символу алфавита его порядковый номер (нумеруя с 0), то шифрование и дешифрование можно выразить формулами [модульной арифметики](https://ru.wikipedia.org/wiki/%D0%9C%D0%BE%D0%B4%D1%83%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F_%D0%B0%D1%80%D0%B8%D1%84%D0%BC%D0%B5%D1%82%D0%B8%D0%BA%D0%B0) [1](https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D1%84%D1%80_%D0%A6%D0%B5%D0%B7%D0%B0%D1%80%D1%8F#cite_note-_2f12c856cf9a3c34-1) [2](https://ru.wikipedia.org/wiki/%D0%A8%D0%B8%D1%84%D1%80_%D0%A6%D0%B5%D0%B7%D0%B0%D1%80%D1%8F#cite_note-_53835a569b2acd83-2):

Шифрование:

$$E_{n}(x) = (x + n) \mod 26$$

Дешифрование:

$$D_n(x) = (x - n) \mod 26$$



# 2. ROT13

**ROT13** ("rotate by 13 places", иногда обозначается как **ROT-13**) — это простой шифр подстановки, который заменяет букву на 13-ю букву после неё в алфавите. Это частный случай шифра Цезаря со сдвигом 13.


1. **Симметричность**: ROT13 является самодвойственным (инволютивным) шифром — одна и та же функция используется как для шифрования, так и для дешифрования, потому что два последовательных применения ROT13 дают исходный текст.
   
   ```
   ROT13(ROT13(text)) = text
   ```


### Базовая реализация ROT13
Реализуйте функцию для шифрования/дешифрования ROT13:

```python
def rot13(text: str) -> str:
    """
    Применяет шифр ROT13 к переданному тексту.
    
    Args:
        text: исходный текст для шифрования/дешифрования
    
    Returns:
        Текст, преобразованный по алгоритму ROT13
    """
    pass

# Примеры использования:
print(rot13("Hello, World!"))        # Должно вернуть: "Uryyb, Jbeyq!"
print(rot13("Uryyb, Jbeyq!"))        # Должно вернуть: "Hello, World!"
print(rot13(rot13("Test")))          # Должно вернуть: "Test"
print(rot13("123!@#"))               # Должно вернуть: "123!@#" (без изменений)
```

### Обобщенный шифр Цезаря
Реализуйте общую функцию шифра Цезаря с произвольным сдвигом:

```python
def caesar_cipher(text: str, shift: int, mode: str = 'encrypt') -> str:
    """
    Применяет шифр Цезаря с заданным сдвигом.
    
    Args:
        text: исходный текст
        shift: величина сдвига (положительное целое число)
        mode: 'encrypt' для шифрования, 'decrypt' для дешифрования
    
    Returns:
        Преобразованный текст
    
    """
    pass

# Примеры использования:
print(caesar_cipher("Hello", 3, 'encrypt'))          # Должно вернуть: "Khoor"
print(caesar_cipher("Khoor", 3, 'decrypt'))          # Должно вернуть: "Hello"
print(caesar_cipher("XYZ", 5, 'encrypt'))            # Должно вернуть: "CDE" (циклический сдвиг)
print(caesar_cipher("Hello, World!", 13, 'encrypt')) # Должно вернуть: "Uryyb, Jbeyq!"
```


# 3. GADERYPOLUKI

**GADERYPOLUKI** - это простой подстановочный шифр, используемый в разведке для шифрования сообщений. Шифр основан на коротком, легко запоминающемся ключе. Ключ записывается в виде парных букв, которые в шифре являются простой заменой.

Наиболее часто используемый ключ - `GA-DE-RY-PO-LU-KI`.

```text
G => A  
g => a  
a => g  
A => G  
D => E  
```

Буквы, которых нет в списке заменителей, остаются в зашифрованном тексте без изменений.

Другие ключи, часто используемые скаутами:

```text
PO-LI-TY-KA-RE-NU
KA-CE-MI-NU-TO-WY
KO-NI-EC-MA-TU-RY
ZA-RE-WY-BU-HO-KI
BA-WO-LE-TY-KI-JU
RE-GU-LA-MI-NO-WY
```

Вам нужно реализовать функции для шифрования и дешифрования сообщений с использованием шифра **GADERYPOLUKI**.

- **Функция кодирования:** Преобразует сообщение, используя подстановки из заданного ключа.
- **Функция декодирования:** Преобразует зашифрованное сообщение обратно в исходное, используя тот же ключ.

- Функция должна принимать два параметра:
    1. Входное сообщение (строка) — может содержать строчные и прописные буквы, а также пробелы.
    2. Входной ключ (строка) — строка, содержащая только строчные буквы, которая задает правила подстановки.
- Подстановка должна быть чувствительна к регистру: строчные буквы кодируются в строчные, прописные — в прописные.

**Пример**

```python
def encode(message, key):
    # Ваша реализация кодирования
    pass

def decode(encrypted_message, key):
    # Ваша реализация декодирования
    pass



 encode("ABCD", "agedyropulik");             // => GBCE 
 encode("Ala has a cat", "gaderypoluki");    // => Gug hgs g cgt 
 decode("Dkucr pu yhr ykbir","politykarenu") // => Dance on the table
 decode("Hmdr nge brres","regulaminowy")     // => Hide our beers
```


# 4. Метод Диффи-Хеллмана

**Метод Диффи-Хеллмана** — это протокол обмена криптографическими ключами, который позволяет двум сторонам, никогда не общавшимся ранее, совместно установить общий секретный ключ по незащищенному каналу связи. Этот общий секрет может затем использоваться для симметричного шифрования последующих сообщений.


Протокол основан на операции **возведения в степень по модулю простого числа** и использует одностороннюю функцию (легко вычислить, но трудно обратить без дополнительной информации).

1. **Общедоступные параметры:**
   - $p$ — большое простое число (модуль)
   - $g$ — первообразный корень по модулю p (генератор)

2. **Секретные ключи сторон:**
   - $a$ — секретный ключ Алисы (случайное целое число, 1 < a < p-1)
   - $b$ — секретный ключ Боба (случайное целое число, 1 < b < p-1)

3. **Открытые ключи:**
   - $A = g^a \mod p$ — открытый ключ Алисы
   - $B = g^b \mod p$ — открытый ключ Боба

4. **Общий секретный ключ:**
   - У Алисы: $K = B^a \mod p = (g^b)^a \mod p = g^(ab) \mod p$
   - У Боба: $K = A^b \mod p = (g^a)^b \mod p = g^(ab) \mod p$


Реализуйте функции для вычисления открытых ключей и общего секрета:

```python
def generate_public_key(secret: int, g: int, p: int) -> int:
    """
    Генерирует открытый ключ на основе секретного ключа.
    
    Args:
        secret: секретный ключ (a или b)
        g: генератор (первообразный корень по модулю p)
        p: простое число (модуль)
    """
    pass

def generate_shared_secret(other_public: int, my_secret: int, p: int) -> int:
    """
    Вычисляет общий секретный ключ.
    
    Args:
        other_public: открытый ключ другой стороны
        my_secret: собственный секретный ключ
        p: простое число (модуль)
    """
    pass
```


# 5. Потоковый шифр


Потоковый шифр использует **генератор псевдослучайных чисел (PRNG)** для создания бесконечной последовательности ключевых битов, которые затем комбинируются с открытым текстом с помощью операции XOR (исключающее ИЛИ). Безопасность зависит от качества PRNG: его вывод должен быть непредсказуемым, даже если известен алгоритм генерации.

Один из исторически интересных подходов — использование **квадратного корня из неквадратичного числа** как источник псевдослучайных цифр. Идея в том, что дробная часть квадратного корня из числа, которое не является полным квадратом, выглядит случайной.

1. Выберите начальное число `S` (seed), которое НЕ является полным квадратом
2. Вычислите `sqrt(S)` с высокой точностью
3. Возьмите дробную часть (цифры после запятой)
4. Группируйте цифры для формирования ключевых байтов

```
sqrt(1337) = 36.5650105975644426586610651828...
Дробная часть: 5650105975644426586610651828...
Группируем по 2 цифры: 56, 50, 10, 59, 75, 64, 44, 26, 58, 66, 10, 65, 18, 28...
Преобразуем в байты: 56, 50, 10, 59, 75, 64, 44, 26, 58, 66, 10, 65, 18, 28...
```


Для числа `S`, которое не является полным квадратом:
- `sqrt(S)` — иррациональное число
- Его десятичное представление бесконечно и непериодично
- Последовательность цифр проходит статистические тесты на случайность
- Однако это детерминировано: тот же `S` даст ту же последовательность


Потоковый шифр работает по формуле:

```
Шифртекст[i] = ОткрытыйТекст[i] XOR Ключ[i]
```

где `Ключ[i]` — i-й байт из генератора.

Для дешифрования используется та же операция:
```
ОткрытыйТекст[i] = Шифртекст[i] XOR Ключ[i]
```

### Свойства XOR
- `A XOR 0 = A`
- `A XOR A = 0`
- `(A XOR B) XOR B = A`
- Операция коммутативна и ассоциативна

Необходимо реализовать такой шифр.

# 6. Взломать пароль

Вам нужно найти пароль от программы, которая находится в директории `data/`. В директории содержатся две версии программы: для Windows — `app.exe`, и для Linux — `app`.

Задание:

1. Проанализировать программу и выяснить, какой пароль она использует.
2. Определить, каким алгоритмом зашифрован этот пароль.
3. Найти способ расшифровать пароль, чтобы получить доступ к программе.

# 5. Преобразование массива строк в одну строку на основе средних значений символов

- Вам дается массив строк, в котором каждая строка состоит из строчных букв и пробелов. Все строки в массиве имеют одинаковую длину.
- Для каждого символа в выходной строке, его значение должно быть средним значением соответствующих символов во всех входных строках.
    - Пример: 1-й символ выходной строки будет равен среднему значению 1-го символа всех входных строк.
    - Если среднее значение не является целым числом, его нужно округлить в меньшую сторону.

- Для каждого символа в строках:
    - Пробелам присваивается значение 0.
    - Каждой букве присваивается числовое значение согласно ее алфавитному индексу ($a$ = 1, $b$ = 2, $c$ = 3 и так далее).
- Среднее значение для каждого символа рассчитывается по формуле: $\mu = \frac{\sigma}{L}$​ где:
    - $μ$ — индекс алфавитного символа для каждого символа выходной строки.
    - $σ$ — сумма алфавитных индексов для соответствующих символов всех строк.
    - $L$ — длина массива строк.

Пример:

```python
def transform_strings(strings):
    # Ваш код здесь
    pass

s1 = "u lk zxuq hfk as fouh"
s2 = "y l zpuv xe at sicd"
s3 = "welvayfuqbfpeaauaqcrc"

strings = [s1, s2, s3]
result = transform_strings(strings)
print(result)  # Должно вывести "walk your dog at nine"
```