
`Python` представляет популярный высокоуровневый язык программирования, который предназначен для создания приложений различных типов. Это и веб-приложения, и игры, и настольные программы, и работа с базами данных. Довольно большое распространение питон получил в области машинного обучения и исследований искусственного интеллекта.

Впервые язык `Python` был анонсирован в 1991 году голландским разработчиком Гвидо Ван Россумом. С тех пор данный язык проделал большой путь развития. В 2000 году была издана версия 2.0, а в 2008 году - версия 3.0. Несмотря на вроде такие большие промежутки между версиями постоянно выходят подверсии. Так, текущей актуальной версией на момент написания данного материала является  3.11, которая вышла в октябре 2022 года.

Основные особенности языка программирования `Python`:

-   Скриптовый язык. Код программ определяется в виде скриптов.
    
-   Поддержка самых различных парадигм программирования, в том числе объектно-ориентированной и функциональной парадигм.
    
-   Интерпретация программ. Для работы со скриптами необходим интерпретатор, который запускает и выполняет скрипт.
    
    Выполнение программы на `Python` выглядит следующим образом. Сначала мы пишим в текстовом редакторе скрипт с набором выражений на данном языке программирования. Передаем этот скрипт на выполнение интерпретатору. Интерпретатор транслирует код в промежуточный байткод, а затем виртуальная машина переводит полученный байткод в набор инструкций, которые выполняются операционной системой.
    
    Здесь стоит отметить, что хотя формально трансляция интерпретатором исходного кода в байткод и перевод байткода виртуальной машиной в набор машинных команд представляют два разных процесса, но фактически они объединены в самом интерпретаторе.
    
    ![Выполнение программы на Python](https://metanit.com/python/tutorial/pics/1.9.png)
-   Портативность и платформонезависимость. Не имеет значения, какая у нас операционная система - Windows, Mac OS, Linux, нам достаточно написать скрипт, который будет запускаться на всех этих ОС при наличии интерпретатора
    
-   Автоматическое управление памяти
    
-   Динамическая типизация
    
 `Python` - очень простой язык программирования, он имеет лаконичный и в то же время довольно простой и понятный синтаксис. Соответственно его легко изучать, и собственно это одна из причин, по которой он является одним из самых популярных языков программирования именно для обучения. В частности, в 2014 году он был признан самым популярным языком программирования для обучения в США.
 
Естественные языки — это языки, на которых говорят люди, такие как английский, испанский и французский.
Они не были созданы людьми (хотя люди пытаются навести в них некоторый порядок); они развивались естественным путем.
Формальные языки — это языки, разработанные людьми для конкретных приложений. Для Например, обозначения, которые используют математики, представляют собой формальный язык, который особенно хорошо обозначает отношения между числами и символами. Химики используют формальный язык, чтобы представить химическую структуру молекул. И самое важное:
** Языки программирования — это формальные языки, созданные для записи компьютерных программ.**
В формальных языках обычно действуют строгие правила синтаксиса. Например, `3+3=6` — это
синтаксически правильное математическое утверждение, но `3+ = 3$6` — нет. $H_2O$ – это синтаксически химическая формула правильная, а $_2 Zz$ нет.
# Первая программа 
---
Первый запуск **командной строкой интерпретатора Python**
```python
$ python3
Python 3.3.0 (default, Oct 22 2012, 12:20:36)
[GCC 4.2.1 Compatible Apple Clang 4.0 ((tags/Apple/clang-421.0.60))] on darwin
Type "help", "copyright", "credits" or "license" for more information.
>>> print('hello world')
hello world
>>>
```
Также можно создавать файлы с расширением `.py`
```python
print('Привет, Мир!')
```
И после вызывать
```python
$ python3 helloworld.py
Привет, Мир!
```
Как вы помните для простого запуска `bash` скриптов, в начала файла добваляли так называемый `shebang`, тоже самое можно делать и с файлами `python` 
```bash
#!/usr/bin/env python3
```

```python
#!/usr/bin/env python3
print('Привет, Мир!')
```
Теперь необходимо установить программе атрибут исполнимости, используя команду `chmod`, а затем выполнить программу.
```bash
chmod a+x helloworld.py
```
После этого мы можем запускать программу напрямую, потому что наша операционная система запустит `/usr/bin/env`, который, в свою очередь, найдёт `Python` 3, а значит, сможет запустить наш файл.
```bash
$ ./helloworld.py
Привет, Мир!
```
Интересный факт! Действительно, чтобы запускать программу из любого каталога, можно разместить ее в одном из каталогов, указанных в переменной окружения `PATH`. Переменная окружения `PATH` содержит список каталогов, в которых операционная система ищет исполняемые файлы. Когда вы вызываете программу из командной строки, система просматривает эти каталоги в порядке, указанном в переменной окружения `PATH`. Чтобы узнать, какие каталоги указаны в переменной `PATH`, вы можете выполнить команду `echo $PATH`. Это выведет список каталогов, разделенных двоеточием. Чтобы сделать программу доступной из любого места, вы можете скопировать ее в один из каталогов, перечисленных в переменной `PATH`. Например, если ваша программа называется `helloworld` и вы хотите, чтобы она была доступна в любом каталоге, вы можете скопировать ее в каталог `/usr/local/bin`, если он указан в переменной PATH. После этого вы сможете запустить программу из любого каталога, просто введя команду `./helloworld`.

```terminal
$ echo $PATH
/usr/local/bin:/usr/bin:/bin:/usr/X11R6/bin:/home/swaroop/bin
$ cp helloworld.py /home/swaroop/bin/helloworld
$ helloworld
Привет, Мир!
```
## Комментарии


_Комментарии_ — это любой текст справа от символа `#`, который в основном полезен в качестве примечаний для читателя программы.


##  Базовые операции: Калькулятор на стероидах

Всё просто. Python отлично считает.

```python
a = 5
b = 6
c = a + b
print(c) # Напечатает 11
```

Но сила в том, что числа можно брать у пользователя:

```python
a = float(input("Введите число a: ")) # float — чтобы ловить и дроби
b = float(input("Введите число b: "))
print("Сумма:", a + b)
print("Разность:", a - b)
print("Произведение:", a * b)
print("Деление:", a / b) # Обычное деление (результат всегда float)
print("Степень:", a ** b) # Возведение в степень (a в степени b)
print("Остаток от деления:", a % b) # Например, 10 % 3 = 1
```

---

## Строки: Работа с текстом

Строки — это просто текст в кавычках (одинарных или двойных — неважно).

```python
name = "Иван"
greeting = 'Привет, ' + name + '!' # Конкатенация (склеивание)
print(greeting) # Привет, Иван!
```

Со строками можно делать много крутых штук:

```python

print(len(greeting)) # 
print(greeting.upper()) # 
print(greeting.split()) # 
print(greeting[0]) # 
print(greeting[8:11]) # 
print(greeting[::-1]) # 
```

**f-строки — это магия!** Позволяют вставлять переменные прямо в текст:
```python
age = 17
print(f"Мне {age} лет. Через год мне будет {age + 1}.")
```



## Списки: Универсальные контейнеры

Список — это упорядоченная коллекция чего угодно. Как коробка, в которую можно складывать разные вещи.

```python
my_list = [1, "два", 3.0, True] # Число, строка, дробь, булево значение — всё можно!
print(my_list)
```

Работа со списками интуитивна:
```python
numbers = [1, 2, 3, 4, 5]
numbers.append(6) # Добавить элемент в конец -> [1,2,3,4,5,6]
numbers.reverse() # Развернуть -> [6,5,4,3,2,1]
print(len(numbers)) # Длина списка (6)
print(numbers[0]) # Первый элемент (6)
print(numbers[-1]) # Последний элемент (1) (-1 — это счёт с конца)
```

**Списковые включения — это суперсила Python!** Позволяют создавать списки в одну строку:
```python
squares = [x**2 for x in range(5)] # [0, 1, 4, 9, 16] — квадраты чисел от 0 до 4
even_numbers = [x for x in range(10) if x % 2 == 0] # [0, 2, 4, 6, 8] — только чётные
```


## Словари: Хранилище «Ключ-Значение»

Словарь — это как адресная книга. Вы ищете не по номеру записи (индексу), а по имени (ключу).

```python
person = {
    "name": "Илон",
    "age": 50,
    "companies": ["SpaceX", "Tesla"] # Значением может быть что угодно, даже список!
}

print(person["name"]) # Достать значение по ключу -> "Илон"
person["age"] = 51 # Изменить значение
person["title"] = "CEO" # Добавить новую пару ключ-значение
print(person.keys()) # Все ключи: dict_keys(['name', 'age', 'companies', 'title'])
```


## Кортежи и Множества: Специализированные коллекции

**Кортеж (tuple)** — это как список, но неизменяемый. Как скреплённый стиплером документ — нельзя добавить или удалить страницу.
```python
point = (10, 20) # Часто используются для координат, RGB-цветов и т.д.
print(point[0]) # 10
# point[0] = 5 # Ошибка! Нельзя изменить.
```

**Множество (set)** — хранит только уникальные элементы. Как мешок с шариками: каждый цветной шарик в единственном экземпляре.
```python
my_set = {1, 2, 2, 3, 3, 3}
print(my_set) # {1, 2, 3} — дубликаты автоматически удаляются!
```


## Управление потоком: Принятие решений и циклы

**Условия (if/else):** Как светофор.
```python
age = 19
if age >= 18:
    print("Можно голосовать и водить машину!")
else:
    print("Придётся подождать.")
```

**Циклы (for):** Делать что-то много раз.
```python
fruits = ["яблоко", "банан", "апельсин"]
for fruit in fruits: # Для каждого фрукта в списке фруктов...
    print(f"Я съем {fruit}!")
```

**Циклы (while):** Делать что-то, пока условие истинно.
```python
countdown = 5
while countdown > 0:
    print(countdown)
    countdown -= 1 # Уменьшаем countdown на 1
print("Пуск!")
```

**break и continue:** Управление циклом.
*   `break` — немедленно выйти из цикла (как «аварийный выход»).
*   `continue` — пропустить текущий шаг и перейти к следующему (сказать «дальше!»).


## Функции: Волшебные коробки

Функция — это упакованная инструкция. Вы даёте ей имя, а потом просто вызываете это имя, чтобы выполнить код внутри.

```python
def greet(name): # Объявление функции с параметром 'name'
    """Эта функция приветствует пользователя.""" # Docstring — описание
    print(f"Привет, {name}! Рад тебя видеть.")

greet("Иване") # Вызов функции -> "Привет, Иван! Рад тебя видеть."
```

**return vs print:** `print` просто показывает текст на экране. `return` — возвращает значение из функции, чтобы его можно было использовать дальше в коде.
```python
def add(a, b):
    return a + b # Возвращает результат

result = add(5, 3) # Результат (8) сохраняется в переменную result
print(result * 2) # 16
```

**Лямбда-функции:** Маленькие анонимные функции «на лету».
```python
square = lambda x: x ** 2 # Функция, возводящая в квадрат
print(square(5)) # 25
```


## Работа с файлами: Чтение и запись

```python
# Запись в файл
with open("дневник.txt", "w", encoding="utf-8") as file: # 'w' — write (запись)
    file.write("Сегодня я изучил Python!\n") # \n — перенос строки

# Чтение из файла
with open("дневник.txt", "r", encoding="utf-8") as file: # 'r' — read (чтение)
    content = file.read()
    print(content) # Сегодня я изучил Python!
```

Ключевое слово `with` — это лучшая практика. Оно автоматически закроет файл, даже если произойдёт ошибка.


## Обработка ошибок: Предотвращаем крушение

Если что-то может пойти не так, лучше быть к этому готовым.

```python
try:
    number = int(input("Введите число: ")) # Пользователь может ввести "abc"
    print(10 / number) # Или 0 (деление на ноль)
except ValueError:
    print("Это было не число!") # Ловим ошибку преобразования
except ZeroDivisionError:
    print("На ноль делить нельзя!") # Ловим ошибку деления
except Exception as e:
    print(f"Что-то пошло не так: {e}") # Ловим всё остальное
```



Конечно! Давайте разберём эти продвинутые концепции Python так, как это сделал бы Ричард Фейнман — с ясностью и на простых аналогиях.

***

## Функция MAP: Применить функцию ко всем

Представьте конвейер на заводе. У вас есть коробка деталей (список) и станок (функция). `map` — это рабочий, который берёт каждую деталь из коробки, обрабатывает её на станке и кладёт результат на новый конвейер.

```python
def cubeFn(num): # Станок, который делает из детали куб
    return num**3

a = [1, 2, 3, 4, 5] # Ящик с деталями
result = map(cubeFn, a) # Рабочий (map) обрабатывает каждую деталь станком cubeFn
print(list(result)) # [1, 8, 27, 64, 125] — Готовые изделия
```

**Важно:** `map` возвращает не список, а специальный "итератор". Чтобы увидеть результат, его нужно преобразовать в список с помощью `list()`.

---

## Функция FILTER: Отсеять лишнее

Это тот же рабочий, но теперь его задача — проверять детали. Он оставляет на конвейере только те, что проходят проверку (удовлетворяют условию).

```python
def evenFn(num): # Условие проверки: деталь чётная?
    return num % 2 == 0

a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] # Ящик с деталями
result = filter(evenFn, a) # Рабочий (filter) проверяет и отсеивает нечётные
print(list(result)) # [0, 2, 4, 6, 8, 10] — Только годные детали
```

---

## Лямбда-функции: Функции "на лету"

Иногда станок настолько простой, что строить для него отдельный цех (объявлять функцию через `def`) — нерационально. Лямбда — это маленький переносной инструмент для простых операций.

**Синтаксис:** `lambda аргументы: выражение`

Сравним два подхода:

```python
# Подход 1: Цех (обычная функция)
def cubeFn(num):
    return num**3
print(cubeFn(5)) # 125

# Подход 2: Переносной инструмент (лямбда)
# Создаём инструмент и сразу даём ему имя 'cubefn'
cubefn = lambda num: num**3
print(cubefn(5)) # 125
```

**Где это реально полезно?** Вместе с `map` и `filter`!

```python
a = [1, 2, 3, 4, 5]

# Вместо того чтобы объявлять отдельную функцию cubeFn, делаем всё в одной строке:
cubes = list(map(lambda x: x**3, a)) 
print(cubes) # [1, 8, 27, 64, 125]

# То же с filter:
evens = list(filter(lambda x: x % 2 == 0, a))
print(evens) # [2, 4]
```

Лямбда — это инструмент для быстрых операций, когда объявлять полноценную функцию нецелесообразно.

---

## `*ARGS` и `**KWARGS`: Приём неожиданных гостей

Что, если вы не знаете, сколько аргументов передадут вашей функции? Например, пишете функцию `sum()`, которая должна складывать всё, что ей дадут.

#### *args (Arguments)

`*args` — это способ сказать функции: «собери все позиционные аргументы, которые мне передали, в один кортеж (tuple)».

```python
def addR(*args): # * — волшебный символ, который упаковывает аргументы в кортеж
    print(args)   # Увидим кортеж: (10, 20, 30, 40, ...)
    return sum(args) # Суммируем все элементы кортежа

result = addR(10, 20, 30, 40, 52, 75, 8, 5, 26, 15)
print(result) # Сумма всех чисел
```

#### **kwargs (Keyword Arguments)

`**kwargs` — это способ сказать: «собери все именованные аргументы (в виде `ключ=значение`) в один словарь (dict)».

```python
def func(**kwargs): # ** — упаковывает аргументы в словарь
    print(kwargs)   # Увидим словарь: {'name': 'champ', 'age': 24, 'marks': 99}
    if 'name' in kwargs:
        print(f"Меня зовут {kwargs['name']}")
    if 'age' in kwargs:
        print(f"Мой возраст {kwargs['age']}")
    else:
        print("Ключ не найден")

func(name='champ', age=24, marks=99)
```

**Имена `args` и `kwargs` — это просто договорённость.** Вы можете использовать любые имена, но `*` и `**` — обязательны.

---

## ОБЪЕКТНО-ОРИЕНТИРОВАННОЕ ПРОГРАММИРОВАНИЕ (ООП)

ООП — это способ моделирования реального мира. Мы представляем программу как набор взаимодействующих объектов.

#### Класс — это чертёж

Класс описывает, какими свойствами и поведением будет обладать объект. Это как чертёж дома.

```python
class Student: # Чертёж "Студент"
    year = '2021' # Атрибут класса. Общий для всех студентов 2021 года.

    def __init__(self, name): # Конструктор. Вызывается при создании объекта.
        self.name = name # Атрибут объекта. У каждого студента своё имя.

# Использование:
elon = Student(name='Elon Musk') # По чертежу строим дом — создаём объект
print(elon.name) # "Elon Musk" — свойство объекта
print(elon.year) # "2021" — общее свойство класса
print(type(elon)) # <class '__main__.Student'> — тип нашего объекта
```

*   `self` — это ссылка на сам создаваемый объект. Через `self.name` мы говорим: «у этого конкретного объекта будет свойство `name`».
*   `__init__` — это специальный метод-конструктор, который вызывается при создании нового объекта.

---

### 15. ДЕКОРАТОРЫ: Обёртка для функции

Декоратор — это дизайнер, который берёт вашу функцию и «заворачивает» её в дополнительную логику, не меняя её исходный код.

**Зачем?** Чтобы добавить функционал, общий для многих функций: логирование, замер времени, проверку прав доступа.

```python
# 1. Создаём декоратор (нанимаем дизайнера)
def decoratorFunc(original_func): # original_func — та функция, которую нужно обернуть
    def wrapper(): # wrapper — новая обёртка вокруг original_func
        print("Начало работы") # Добавляем код ДО
        original_func()         # Вызываем исходную функцию
        print("Конец работы")   # Добавляем код ПОСЛЕ
    return wrapper # Возвращаем готовую обёрнутую функцию

# 2. Создаём обычную функцию (исходный предмет)
def subFunc():
    print("Я — обычная функция")

# 3. Применяем декоратор (отдаём предмет дизайнеру на упаковку)
subFunc = decoratorFunc(subFunc) # Теперь subFunc — это обёрнутая функция

# 4. Вызываем
subFunc()
# Начало работы
# Я — обычная функция
# Конец работы
```

В Python есть более красивый синтаксис для применения декоратора — с помощью `@`:

```python
@decoratorFunc # То же самое, что subFunc = decoratorFunc(subFunc)
def subFunc():
    print("Я — обычная функция")

subFunc() # Вызовется уже обёрнутая версия
```

---

### 16. ГЕНЕРАТОРЫ: Экономия памяти

Представьте, что вам нужно посчитать квадраты миллиона чисел. Если использовать списки, вы создадите в памяти огромный список из миллиона элементов, прежде чем начнёте с ним работать.

**Генератор** — это более умный способ. Он не вычисляет и не хранит все значения сразу. Он выдаёт их по одному, «на лету», когда вы его об этом просите. Это экономит кучу памяти!

Ключевое слово `yield` превращает обычную функцию в генератор.

```python
def square(n): # Это генератор
    for i in range(n):
        yield i**2 # yield "выдаёт" значение и приостанавливает функцию

# Использование:
for num in square(10): # В цикле for генератор выдаёт по одному числу за раз
    print(num) # Печатаем 0, 1, 4, 9, 16, ... 81
```

**Что происходит?**
1.  Вы вызываете `square(10)`. Возвращается не список, а объект-генератор.
2.  Цикл `for` в каждой итерации просит у генератора следующее значение.
3.  Генератор выполняет код до первого `yield`, возвращает значение и «засыпает».
4.  На следующей итерации цикла генератор «просыпается» и продолжает с места остановки до следующего `yield`.
5.  Когда значения кончаются, генератор завершает работу.

**Плюсы:** Огромная экономия памяти. Можно работать с бесконечными последовательностями.
**Минусы:** К значениям нельзя обратиться по индексу (типа `generator[5]`), можно только получить следующее.
## Установка и использование библиотек

Сила Python — в его сообществе и тысячах бесплатных библиотек. Установка через `pip` (пакетный менеджер):

```bash
# В командной строке (не в Python!)
pip install requests pandas numpy
```

Использование в коде:
```python
import requests # Для веб-запросов
import pandas as pd # Для анализа данных
import numpy as np # Для научных вычислений

# Пример: скачать страницу из интернета
response = requests.get("https://example.com")
print(response.status_code) # 200 (успех)
```

> **Главный принцип Python:** «Простое лучше сложного». Язык создан для читаемости и практичности. Не усложняйте без необходимости. Экспериментируйте, запускайте код и смотрите, что происходит! Это лучший способ учиться.



# Примеры 

## 1. Извлечение и переназначение элементов списка

Попробуйте несколько поисков:

```python
>>> symlist =['HPQ', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'DOA', 'GOOG']
>>> symlist[0]
'HPQ'
>>> symlist[1]
'AAPL'
>>> symlist[-1]
'GOOG'
>>> symlist[-2]
'DOA'
>>>
```

Попробуйте переназначить одно значение:

```python
>>> symlist[2] = 'AIG'
>>> symlist
['HPQ', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'DOA', 'GOOG']
>>>
```

Возьмите несколько кусочков:

```python
>>> symlist[0:3]
['HPQ', 'AAPL', 'AIG']
>>> symlist[-2:]
['DOA', 'GOOG']
>>>
```

Создайте пустой список и добавьте в него элемент.

```python
>>> mysyms = []
>>> mysyms.append('GOOG')
>>> mysyms
['GOOG']
```

Вы можете переназначить часть списка другому списку. Например:

```python
>>> symlist[-2:] = mysyms
>>> symlist
['HPQ', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'GOOG']
>>>
```

Когда вы это сделаете, размер списка в левой части (`symlist`) будет изменен соответствующим образом, чтобы поместилась правая часть (`mysyms`). Например, в приведенном выше примере последние два элемента `symlist` были заменены единственным элементом в списке `mysyms`.

## 2. Перебор элементов списка

Цикл `for` работает путем перебора данных в такой последовательности, как список. Проверьте это, набрав следующий цикл и наблюдая, что происходит:

```python
>>> for s in symlist:
        print('s =', s)
# Look at the output
```

## 3. Тесты на членство

Используйте оператор `in` или `not in`, чтобы проверить, присутствуют ли `AIG`, `AA` и `CAT` в списке символов.

```python
>>> # Is 'AIG' IN the `symlist`?
True
>>> # Is 'AA' IN the `symlist`?
False
>>> # Is 'CAT' NOT IN the `symlist`?
True
>>>
```

## 4. Добавление, вставка и удаление элементов

Используйте метод `append()`, чтобы добавить символ `RHT` в конец `symlist`.

```python
>>> # append 'RHT'
>>> symlist
['HPQ', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'GOOG', 'RHT']
>>>
```

Используйте метод `insert()`, чтобы вставить символ `AA` в качестве второго элемента в списке.

```python
>>> # Insert 'AA' as the second item in the list
>>> symlist
['HPQ', 'AA', 'AAPL', 'AIG', 'MSFT', 'YHOO', 'GOOG', 'RHT']
>>>
```

Используйте метод `remove()`, чтобы удалить `MSFT` из списка.

```python
>>> # Remove 'MSFT'
>>> symlist
['HPQ', 'AA', 'AAPL', 'AIG', 'YHOO', 'GOOG', 'RHT']
>>>
```

Добавьте дублирующую запись для `YHOO` в конец списка.


```python
>>> # Append 'YHOO'
>>> symlist
['HPQ', 'AA', 'AAPL', 'AIG', 'YHOO', 'GOOG', 'RHT', 'YHOO']
>>>
```
Используйте метод `index()`, чтобы найти первую позицию `YHOO` в списке.

```python
>>> # Find the first index of 'YHOO'
4
>>> symlist[4]
'YHOO'
>>>
```

Посчитайте, сколько раз `YHOO` встречается в списке:

```python
>>> symlist.count('YHOO')
2
>>>
```

Удалите первое появление `YAHOO`.

```python
>>> # Remove first occurrence 'YHOO'
>>> symlist
['HPQ', 'AA', 'AAPL', 'AIG', 'GOOG', 'RHT', 'YHOO']
>>>
```

Just so you know, there is no method to find or remove all occurrences of an item.
However, we'll see an elegant way to do this in section 2.

## 5. Сортировка

Хотите отсортировать список? Используйте метод `sort()`. Попробуйте:

```python
>>> symlist.sort()
>>> symlist
['AA', 'AAPL', 'AIG', 'GOOG', 'HPQ', 'RHT', 'YHOO']
>>>
```

Хотите отсортировать в обратном порядке? Попробуй это:

```python
>>> symlist.sort(reverse=True)
>>> symlist
['YHOO', 'RHT', 'HPQ', 'GOOG', 'AIG', 'AAPL', 'AA']
>>>
```

Примечание. При сортировке списка его содержимое изменяется «на месте». То есть элементы списка перемешиваются, но в результате новый список не создается.

## 6. Собираем все обратно

Хотите взять список строк и объединить их в одну строку? Используйте метод `join()` для таких строк (обратите внимание: на первый взгляд это выглядит забавно).

```python
>>> a = ','.join(symlist)
>>> a
'YHOO,RHT,HPQ,GOOG,AIG,AAPL,AA'
>>> b = ':'.join(symlist)
>>> b
'YHOO:RHT:HPQ:GOOG:AIG:AAPL:AA'
>>> c = ''.join(symlist)
>>> c
'YHOORHTHPQGOOGAIGAAPLAA'
>>>
```

## 7. Списки чего угодно

Списки могут содержать объекты любого типа, включая другие списки (например, вложенные списки).
Попробуйте это:

```python
>>> nums = [101, 102, 103]
>>> items = ['spam', symlist, nums]
>>> items
['spam', ['YHOO', 'RHT', 'HPQ', 'GOOG', 'AIG', 'AAPL', 'AA'], [101, 102, 103]]
```

Обратите пристальное внимание на приведенный выше вывод. `items` — это список из трех элементов.
Первый элемент — это строка, а два других элемента — это списки.

Вы можете получить доступ к элементам во вложенных списках, используя несколько операций индексирования.

```python
>>> items[0]
'spam'
>>> items[0][0]
's'
>>> items[1]
['YHOO', 'RHT', 'HPQ', 'GOOG', 'AIG', 'AAPL', 'AA']
>>> items[1][1]
'RHT'
>>> items[1][1][2]
'T'
>>> items[2]
[101, 102, 103]
>>> items[2][1]
102
>>>
```

Хотя технически возможно составить очень сложный список структуры, как правило, вы хотите, чтобы все было просто. Обычно списки содержат элементы, имеющие одинаковое значение. Для например, список, полностью состоящий из чисел, или список текста струны. Смешивание разных типов данных в одном списке часто это хороший способ взорвать голову, поэтому его лучше избегать.

Вместо создания списка с помощью цикла можно использовать понимание списка с довольно понятным синтаксисом.

```python
[i**2 for i in range(4)]
[0, 1, 4, 9]
```

## 7. Файлы

Эти упражнения зависят от файла `data/portfolio.csv`. Файл содержит список строк с информацией о портфеле акций. Предполагается, что вы работаете в `$YOUR_PATH_TO_COURSE/course_embedded_systems/course/computer science/chapter5/`. Если вы не уверены, вы можете узнать, где думает Python он работает:

```python
>>> import os
>>> os.getcwd()
'$PWD' # Output vary
>>>
```
Сначала попробуйте прочитать весь файл сразу как большую строку:

```python
>>> with open('Data/portfolio.csv', 'rt') as f:
        data = f.read()

>>> data
'name,shares,price\n"AA",100,32.20\n"IBM",50,91.10\n"CAT",150,83.44\n"MSFT",200,51.23\n"GE",95,40.37\n"MSFT",50,65.10\n"IBM",100,70.44\n'
>>> print(data)
name,shares,price
"AA",100,32.20
"IBM",50,91.10
"CAT",150,83.44
"MSFT",200,51.23
"GE",95,40.37
"MSFT",50,65.10
"IBM",100,70.44
>>>
```
Следует отметить, что в приведенном выше примере Python имеет два режима работы. выход. В первом режиме, когда вы вводите data в командной строке, Python показывает необработанное строковое представление, включая кавычки и `escape коды`. Когда вы вводите `print(data)`, вы получаете фактически отформатированный вывод строки. 
Хотя прочитать файл целиком сразу несложно, зачастую это не самая простая задача. наиболее подходящий способ сделать это, особенно если файл оказывается огромный или содержит строки текста, которые вы хотите обрабатывать по одной время.
Чтобы прочитать файл построчно, используйте такой цикл:

```python
>>> with open('Data/portfolio.csv', 'rt') as f:
        for line in f:
            print(line, end='')

name,shares,price
"AA",100,32.20
"IBM",50,91.10
...
>>>
```

Когда вы используете этот код, как показано, строки читаются до конца
файл достигнут, и в этот момент цикл останавливается.

В некоторых случаях вам может потребоваться вручную прочитать или пропустить
*одна* строка текста (например, возможно, вы хотите пропустить первую строку
заголовков столбцов).

```python
>>> f = open('Data/portfolio.csv', 'rt')
>>> headers = next(f)
>>> headers
'name,shares,price\n'
>>> for line in f:
    print(line, end='')

"AA",100,32.20
"IBM",50,91.10
...
>>> f.close()
>>>
```

`next()` возвращает следующую строку текста в файле. Если бы вы вызывали его несколько раз, вы бы получили последовательные строки. Однако, как вы знаете, цикл for уже использует `next()` для получения данных.
Таким образом, вы обычно не будете вызывать его напрямую, если не пытаетесь явно пропустить или прочитать одну строку, как показано.

Прочитав строки файла, вы можете начать выполнять дополнительную обработку, например разделение.
Например, попробуйте следующее:

```python
>>> f = open('Data/portfolio.csv', 'rt')
>>> headers = next(f).split(',')
>>> headers
['name', 'shares', 'price\n']
>>> for line in f:
    row = line.split(',')
    print(row)

['"AA"', '100', '32.20\n']
['"IBM"', '50', '91.10\n']
...
>>> f.close()
```

*Примечание. В этих примерах `f.close()` вызывается явно, поскольку оператор `with` не используется.*

## 8. Чтение из файла

Теперь, когда вы знаете, как читать файл, давайте напишем программу, выполняющую простые вычисления.

Столбцы в `portfolio.csv` соответствуют названию акции, количеству акций и цена покупки одного пакета акций. Напишите программу под названием `pcost.py`, который открывает этот файл, читает все строки и вычисляет, как
сколько стоит покупка всех акций в портфеле.

*Подсказка: чтобы преобразовать строку в целое число, используйте `int(s)`. Чтобы преобразовать строку в число с плавающей запятой, используйте `float(s)`.*

Ваша программа должна вывести вывод, подобный следующему:

```bash
Total cost 44671.15
```

##  9. Другие виды «файлов»

Что делать, если вы хотите прочитать нетекстовый файл, например сжатый gzip? файл данных? Встроенная функция `open()` вам здесь не поможет, но В Python есть библиотечный модуль `gzip`, который может читать сжатые `gzip` файлы.

Попробуйте 

```python
>>> import gzip
>>> with gzip.open('Data/portfolio.csv.gz', 'rt') as f:
    for line in f:
        print(line, end='')

... look at the output ...
>>>
```

Примечание. Включение файлового режима `rt` здесь имеет [решающее значение](https://docs.python.org/3/library/functions.html#open). Если вы забудете про это, вы получите байтовые строки вместо обычных текстовых строк.

## 10. Определение функции

Попробуйте определить простую функцию:

```python
>>> def greeting(name):
        'Issues a greeting'
        print('Hello', name)

>>> greeting('Guido')
Hello Guido
>>> greeting('Paula')
Hello Paula
>>>
```

Если первый оператор функции является строкой, он служит документацией.
Попробуйте ввести команду, например `help(greeting)`, чтобы увидеть ее отображение.

## 11. Превращение скрипта в функцию

Возьмите код, который вы написали для программы pcost.py, и превратите его в функцию `portfolio_cost(filename)`. Функция принимает имя файла в качестве входных данных, считывает данные портфеля из этого файла и возвращает общую стоимость портфеля в виде числа с плавающей запятой.

Чтобы использовать вашу функцию, измените свою программу так, чтобы она выглядела как-то
так:

```python
def portfolio_cost(filename):
    ...
    # Your code here
    ...

cost = portfolio_cost('data/portfolio.csv')
print('Total cost:', cost)
```

Когда вы запустите программу, вы должны увидеть тот же результат, что и раньше. После запуска программы вы также можете вызвать свою функцию в интерактивном режиме, набрав это:

```bash
bash $ python3 -i pcost.py
```

Это позволит вам вызывать функцию из интерактивного режима.

```python
>>> portfolio_cost('Data/portfolio.csv')
44671.15
>>>
```

Возможность интерактивно экспериментировать с кодом полезна для тестирования и отладки.

## 12. Обработка ошибок

Что произойдет, если вы попробуете свою функцию с файлом, в котором отсутствуют некоторые поля?

```python
>>> portfolio_cost('Data/missing.csv')
Traceback (most recent call last):
    File "<stdin>", line 1, in <module>
    File "pcost.py", line 11, in portfolio_cost
    nshares    = int(fields[1])
ValueError: invalid literal for int() with base 10: ''
>>>
```

На этом этапе вы столкнулись с решением. Чтобы программа работала вы можете либо очистить исходный входной файл, удалив плохие строк или вы можете изменить свой код для обработки плохих строк в некоторых
образом.

Измените программу `pcost.py`, чтобы перехватить исключение и вывести предупреждение сообщение и продолжите обработку остальной части файла.

## 13. Использование библиотечной функции

Python поставляется с большой стандартной библиотекой полезных функций. Одна из библиотек, которая может быть здесь полезна, — это модуль `csv`. Вам следует использовать его всякий раз, когда вам приходится работать с файлами данных CSV. Вот пример того, как это работает:

```python
>>> import csv
>>> f = open('Data/portfolio.csv')
>>> rows = csv.reader(f)
>>> headers = next(rows)
>>> headers
['name', 'shares', 'price']
>>> for row in rows:
        print(row)

['AA', '100', '32.20']
['IBM', '50', '91.10']
['CAT', '150', '83.44']
['MSFT', '200', '51.23']
['GE', '95', '40.37']
['MSFT', '50', '65.10']
['IBM', '100', '70.44']
>>> f.close()
>>>
```

Одна из приятных особенностей модуля `csv` заключается в том, что он обрабатывает множество низкоуровневых деталей, таких как кавычки и правильное разделение запятых. В приведенном выше выводе вы заметите, что из имен в первом столбце удалены двойные кавычки.

Измените свою программу `pcost.py` так, чтобы она использовала модуль `csv` для анализа, и попробуйте запустить более ранние примеры.

## 14. Чтение из командной строки

В программе `pcost.py` имя входного файла жестко встроено в код:

```python
# pcost.py

def portfolio_cost(filename):
    ...
    # Your code here
    ...

cost = portfolio_cost('Data/portfolio.csv')
print('Total cost:', cost)
```

Это нормально для обучения и тестирования, но в реальной программе вы, вероятно, не будете этого делать.

Вместо этого вы можете передать имя файла в качестве аргумента скрипту. Попробуйте изменить нижнюю часть программы следующим образом:

```python
# pcost.py
import sys

def portfolio_cost(filename):
    ...
    # Your code here
    ...

if len(sys.argv) == 2:
    filename = sys.argv[1]
else:
    filename = 'Data/portfolio.csv'

cost = portfolio_cost(filename)
print('Total cost:', cost)
```

`sys.argv` — это список, содержащий переданные аргументы в командной строке (если таковые имеются).

Чтобы запустить вашу программу, вам нужно запустить `Python` из терминала.
Например, из `bash` в `Unix`:

```bash
bash % python3 pcost.py Data/portfolio.csv
Total cost: 44671.15
bash %
```

## 15. Список кортежей

Файл `data/portfolio.csv` содержит список акций в портфеле. Ранее вы написали функцию portfolio_cost(filename)`, которая читает этот файл и провели простой расчет.

В этом файле определите функцию `read_portfolio(filename)`, которая открывает данный файл портфолио и считывает его в список кортежей. Для этого вам нужно внести несколько незначительных изменений в приведенный выше код.

Во-первых, вместо определения `total_cost = 0` вы создадите переменную изначально установлен пустой список. Например:

```python
portfolio = []
```

Далее, вместо суммирования стоимости, вы превратите каждую строку в кортеж, и добавите его в этот список. Например:

```python
for row in rows:
    holding = (row[0], int(row[1]), float(row[2]))
    portfolio.append(holding)
```


Наконец, вы вернете результирующий список `portfolio`.

Поэкспериментируйте со своей функцией в интерактивном режиме

*Подсказка: используйте `-i` при выполнении файла в терминале*

```python
>>> portfolio = read_portfolio('Data/portfolio.csv')
>>> portfolio
[('AA', 100, 32.2), ('IBM', 50, 91.1), ('CAT', 150, 83.44), ('MSFT', 200, 51.23),
    ('GE', 95, 40.37), ('MSFT', 50, 65.1), ('IBM', 100, 70.44)]
>>>
>>> portfolio[0]
('AA', 100, 32.2)
>>> portfolio[1]
('IBM', 50, 91.1)
>>> portfolio[1][1]
50
>>> total = 0.0
>>> for s in portfolio:
        total += s[1] * s[2]

>>> print(total)
44671.15
>>>
```

Этот список кортежей, который вы создали, очень похож на двумерный массив. Например, вы можете получить доступ к определенному столбцу и строке, используя такой поиск, как `portfolio[row][column]`, где `row` и `column` — целые числа.

Тем не менее, вы также можете переписать последний цикл for, используя такой оператор:

```python
>>> total = 0.0
>>> for name, shares, price in portfolio:
            total += shares*price

>>> print(total)
44671.15
>>>
```

## 16: Список словарей

Возьмите функцию, которую вы написали, и измените ее так, чтобы каждая акция в портфеле представляла словарь, а не кортеж. В этом словаре используйте имена полей `name`, `shares` и `price` для представления различных столбцов во входном файле.

Поэкспериментируйте с этой новой функцией так же, как вы это делали в

```python
>>> portfolio = read_portfolio('Data/portfolio.csv')
>>> portfolio
[{'name': 'AA', 'shares': 100, 'price': 32.2}, {'name': 'IBM', 'shares': 50, 'price': 91.1},
    {'name': 'CAT', 'shares': 150, 'price': 83.44}, {'name': 'MSFT', 'shares': 200, 'price': 51.23},
    {'name': 'GE', 'shares': 95, 'price': 40.37}, {'name': 'MSFT', 'shares': 50, 'price': 65.1},
    {'name': 'IBM', 'shares': 100, 'price': 70.44}]
>>> portfolio[0]
{'name': 'AA', 'shares': 100, 'price': 32.2}
>>> portfolio[1]
{'name': 'IBM', 'shares': 50, 'price': 91.1}
>>> portfolio[1]['shares']
50
>>> total = 0.0
>>> for s in portfolio:
        total += s['shares']*s['price']

>>> print(total)
44671.15
>>>
```

Здесь вы заметите, что доступ к различным полям каждой записи осуществляется по именам ключей, а не по числовым номерам столбцов. Это часто предпочтительнее, потому что полученный код легче читать позже.

Просмотр больших словарей и списков может быть затруднительным. Чтобы очистить вывод для отладки, рассмотрите возможность использования функции pprint.

```python
>>> from pprint import pprint
>>> pprint(portfolio)
[{'name': 'AA', 'price': 32.2, 'shares': 100},
    {'name': 'IBM', 'price': 91.1, 'shares': 50},
    {'name': 'CAT', 'price': 83.44, 'shares': 150},
    {'name': 'MSFT', 'price': 51.23, 'shares': 200},
    {'name': 'GE', 'price': 40.37, 'shares': 95},
    {'name': 'MSFT', 'price': 65.1, 'shares': 50},
    {'name': 'IBM', 'price': 70.44, 'shares': 100}]
>>>
```


## 17. Подсчет

Попробуйте несколько простых примеров подсчета:

```python
>>> for n in range(10):            # Count 0 ... 9
        print(n, end=' ')

0 1 2 3 4 5 6 7 8 9
>>> for n in range(10,0,-1):       # Count 10 ... 1
        print(n, end=' ')

10 9 8 7 6 5 4 3 2 1
>>> for n in range(0,10,2):        # Count 0, 2, ... 8
        print(n, end=' ')

0 2 4 6 8
>>>
```

## 18. Дополнительные операции с последовательностями

Поэкспериментируйте в интерактивном режиме с некоторыми операциями сокращения последовательности.

```python
>>> data = [4, 9, 1, 25, 16, 100, 49]
>>> min(data)
1
>>> max(data)
100
>>> sum(data)
204
>>>
```

Попробуйте перебрать данные.

```python
>>> for x in data:
        print(x)

4
9
...
>>> for n, x in enumerate(data):
        print(n, x)

0 4
1 9
2 1
...
>>>
```


## 19. zip()

В файле `data/portfolio.csv` первая строка содержит заголовки столбцов.

```python
>>> f = open('Data/portfolio.csv')
>>> rows = csv.reader(f)
>>> headers = next(rows)
>>> headers
['name', 'shares', 'price']
>>>
```

Однако что, если бы вы могли использовать заголовки для чего-нибудь полезного? Здесь на сцену выходит функция `zip()`. Сначала попробуйте соединить заголовки файлов со строкой данных:

```python
>>> row = next(rows)
>>> row
['AA', '100', '32.20']
>>> list(zip(headers, row))
[ ('name', 'AA'), ('shares', '100'), ('price', '32.20') ]
>>>
```

Обратите внимание, как `zip()` соединяет заголовки столбцов со значениями столбцов. Мы использовали здесь `list()`, чтобы превратить результат в список, чтобы вы могли его увидеть. Обычно `zip()` создает итератор, который должен использоваться циклом `for`.

Это объединение является промежуточным шагом к созданию словаря. Теперь попробуйте следующее:

```python
>>> record = dict(zip(headers, row))
>>> record
{'price': '32.20', 'name': 'AA', 'shares': '100'}
>>>
```

Это преобразование — один из самых полезных приемов, о которых следует знать при обработке большого количества файлов данных. Например, предположим, что вы хотите, чтобы программа `pcost.py` работала с различными входными файлами, но без учета фактического номера столбца, в котором указаны имя, акции и цена.


## 20. Списки

Попробуйте несколько простых обработок списков, чтобы ознакомиться с синтаксисом.

```python
>>> nums = [1,2,3,4]
>>> squares = [ x * x for x in nums ]
>>> squares
[1, 4, 9, 16]
>>> twice = [ 2 * x for x in nums if x > 2 ]
>>> twice
[6, 8]
>>>
```

Обратите внимание, как генераторы списков создают новый список с данными, соответствующим образом преобразованными или отфильтрованными.

## 21. Сокращение последовательности

Рассчитайте общую стоимость портфеля, используя один оператор `Python`.

```python
>>> portfolio = read_portfolio('data/portfolio.csv')
>>> cost = sum([ s['shares'] * s['price'] for s in portfolio ])
>>> cost
44671.15
>>>
```

После того, как вы это сделаете, покажите, как можно вычислить текущую стоимость портфеля с помощью одного оператора.

```python
>>> value = sum([ s['shares'] * prices[s['name']] for s in portfolio ])
>>> value
28686.1
>>>
```
Обе вышеуказанные операции являются примером сокращения карты. Понимание списка отображает операцию по всему списку.

```python
>>> [ s['shares'] * s['price'] for s in portfolio ]
[3220.0000000000005, 4555.0, 12516.0, 10246.0, 3835.1499999999996, 3254.9999999999995, 7044.0]
>>>
```

Затем функция `sum()` выполняет сокращение результата:

```python
>>> sum(_)
44671.15
>>>
```

Обладая этими знаниями, вы теперь готовы запустить стартап, работающий с большими данными.

## 22: Запросы данных


Попробуйте следующие примеры различных запросов к данным.

Во-первых, список всех портфельных холдингов, содержащих более 100 акций.

```python
>>> more100 = [ s for s in portfolio if s['shares'] > 100 ]
>>> more100
[{'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 51.23, 'name': 'MSFT', 'shares': 200}]
>>>
```

Все портфельные активы MSFT и IBM.

```python
>>> msftibm = [ s for s in portfolio if s['name'] in {'MSFT','IBM'} ]
>>> msftibm
[{'price': 91.1, 'name': 'IBM', 'shares': 50}, {'price': 51.23, 'name': 'MSFT', 'shares': 200},
  {'price': 65.1, 'name': 'MSFT', 'shares': 50}, {'price': 70.44, 'name': 'IBM', 'shares': 100}]
>>>
```

Список всех активов портфеля стоимостью более 10 000 долларов США.

```python
>>> cost10k = [ s for s in portfolio if s['shares'] * s['price'] > 10000 ]
>>> cost10k
[{'price': 83.44, 'name': 'CAT', 'shares': 150}, {'price': 51.23, 'name': 'MSFT', 'shares': 200}]
>>>
```

## 23: Извлечение данных

Покажите, как можно построить список кортежей `(name,shares)`, где `name` и `shares` берутся из `portfolio`.

```python
>>> name_shares =[ (s['name'], s['shares']) for s in portfolio ]
>>> name_shares
[('AA', 100), ('IBM', 50), ('CAT', 150), ('MSFT', 200), ('GE', 95), ('MSFT', 50), ('IBM', 100)]
>>>
```


Если вы замените квадратные скобки (`[`,`]`) на фигурные скобки (`{`, `}`), вы получите нечто, известное как понимание множеств.
Это дает вам уникальные или отличные значения.

Например, это определяет набор уникальных названий акций, которые появляются в портфеле:

```python
>>> names = { s['name'] for s in portfolio }
>>> names
{ 'AA', 'GE', 'IBM', 'MSFT', 'CAT' }
>>>
```

Если вы укажете пары «ключ:значение», вы сможете создать словарь. Например, создайте словарь, который сопоставит название акции с общим количеством принадлежащих акций.

```python
>>> holdings = { name: 0 for name in names }
>>> holdings
{'AA': 0, 'GE': 0, 'IBM': 0, 'MSFT': 0, 'CAT': 0}
>>>
```

Эта последняя функция известна как **словарное понимание**. Давайте сведем в таблицу:

```python
>>> for s in portfolio:
        holdings[s['name']] += s['shares']

>>> holdings
{ 'AA': 100, 'GE': 95, 'IBM': 150, 'MSFT':250, 'CAT': 150 }
>>>
```

Попробуйте этот пример, который фильтрует словарь «цены» только до тех имен, которые появляются в портфолио:

```python
>>> portfolio_prices = { name: prices[name] for name in names }
>>> portfolio_prices
{'AA': 9.22, 'GE': 13.48, 'IBM': 106.28, 'MSFT': 20.89, 'CAT': 35.46}
>>>
```


## 24. Первоклассные данные

В файле `data/portfolio.csv` мы читаем данные, организованные в виде столбцов, которые выглядят следующим образом:

```csv
name,shares,price
"AA",100,32.20
"IBM",50,91.10
...
```

В предыдущем коде мы использовали модуль `CSV` для чтения файла, но все равно приходилось выполнять преобразования типов вручную. Например:

```python
for row in rows:
    name   = row[0]
    shares = int(row[1])
    price  = float(row[2])
```


Этот вид преобразования также можно выполнить более умным способом, используя некоторые базовые операции со списками.

Создайте список Python, содержащий имена функций преобразования, которые вы будете использовать для преобразования каждого столбца в соответствующий тип:

```python
>>> types = [str, int, float]
>>>
```

Причина, по которой вы даже можете создать этот список, заключается в том, что в Python все *первоклассно*. Итак, если вы хотите иметь список функций, это нормально. Элементы в созданном вами списке являются функциями для преобразования значения `x` в заданный тип (например, `str(x)`, `int(x)`, `float(x)`.

Теперь прочитайте строку данных из вышеуказанного файла:

```python
>>> import csv
>>> f = open('Data/portfolio.csv')
>>> rows = csv.reader(f)
>>> headers = next(rows)
>>> row = next(rows)
>>> row
['AA', '100', '32.20']
>>>
```

Как уже отмечалось, этой строки недостаточно для вычислений, поскольку типы неверны. Например:

```python
>>> row[1] * row[2]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: can't multiply sequence by non-int of type 'str'
>>>
```

Однако, возможно, данные можно сопоставить с типами, указанными вами в `types`. Например:

```python
>>> types[1]
<type 'int'>
>>> row[1]
'100'
>>>
```

Попробуйте преобразовать одно из значений:

```python
>>> types[1](row[1])     # Same as int(row[1])
100
>>>
```

Попробуйте преобразовать другое значение:

```python
>>> types[2](row[2])     # Same as float(row[2])
32.2
>>>
```

Попробуйте выполнить расчет с преобразованными значениями:

```python
>>> types[1](row[1])*types[2](row[2])
3220.0000000000005
>>>
```

`zip` типы столбцов с полями и посмотрите на результат:

```python
>>> r = list(zip(types, row))
>>> r
[(<type 'str'>, 'AA'), (<type 'int'>, '100'), (<type 'float'>,'32.20')]
>>>
```

Вы заметите, что здесь преобразование типа связано со значением. Например, `int` сочетается со значением `100`.

`zip` список полезен, если вы хотите выполнить преобразования всех значений одно за другим. Попробуй это:

```python
>>> converted = []
>>> for func, val in zip(types, row):
          converted.append(func(val))
...
>>> converted
['AA', 100, 32.2]
>>> converted[1] * converted[2]
3220.0000000000005
>>>
```

Убедитесь, что вы понимаете, что происходит в приведенном выше коде. В цикле переменная func — это одна из функций преобразования типов (например, str, int и т. д.), а переменная val — одно из значений.
например «АА», «100». Выражение `func(val)` преобразует значение (что-то вроде приведения типа).

Приведенный выше код можно сжать в одно представление списка.

```python
>>> converted = [func(val) for func, val in zip(types, row)]
>>> converted
['AA', 100, 32.2]
>>>
```

## 25: Создание словарей

Помните, как функция `dict()` может легко создать словарь, если у вас есть последовательность имен и значений ключей? Давайте сделаем словарь из заголовков столбцов:

```python
>>> headers
['name', 'shares', 'price']
>>> converted
['AA', 100, 32.2]
>>> dict(zip(headers, converted))
{'price': 32.2, 'name': 'AA', 'shares': 100}
>>>
```

Конечно, если вы разбираетесь в понимании списков, вы можете выполнить все преобразование за один шаг, используя:

```python
>>> { name: func(val) for name, func, val in zip(headers, types, row) }
{'price': 32.2, 'name': 'AA', 'shares': 100}
>>>
```