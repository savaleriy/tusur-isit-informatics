
# Обязательные задания 


> **Половину задач нужно решить на python, половину на Си. Вы выбираете сами**

## 1. 

> `task_1{.py|c}`

Дано расстояние в метрах, вводимое пользователем. Переведите метры в
сантиметры, результат выведите в консоль в формате «Distance in centimeters: `distance`»;

## 2. 

> `task_2{.py|c}`

Известны два расстояния, вводимые пользователем: одно в километрах,
другое — в метрах. С помощью условной конструкции выведите наименьшее расстояние;

## 3. 

> `task_3{.py|c}`

Дан массив с числами от 0 до 9. Используя цикл for, выведите в консоль таблицу
умножения для числа, вводимого пользователем. 

## 4. 

> `task_4{.py|c}`

Определите, является ли число a делителем числа b;
 
## 5. 

> `task_5{.py|c}`

Напишите программу вывода на экран числа, вводимого с клавиатуры. После
выводимого числа должно следовать сообщение: «Thats the number you entered
`number`;

## 6. 

> `task_6{.py|c}`

Если число m больше числа n, то выведите на экран «Number m > n», Если
число m меньше числа n, то выведите на экран «Number m < n», в противном случае
выведите сообщение «The numbers are equal»;

## 7. 

> `task_7{.py|c}`

Дан радиус окружности. Найдите ее диаметр;
Найдите:
	- сумму всех целых чисел от 100 до 500;
	- сумму всех целых чисел от a до 500 (значение a вводится с клавиатуры; a<500);

## 8. 

> `task_8{.py|c}`

Напишите программу, которая запрашивает у пользователя его имя и выводит
сообщение в следующем формате «Hello, `username`»;

## 9. 

> `task_9{.py|c}`

Пусть a, b, c – переменные, которым присваиваются введенные числа, а
переменная m в конечном итоге должна будет содержать значение наибольшей
переменной;

## 10. 

>`task_10{.py|c}`

Пользователь вводит два числа. Одно присваивается одной переменной, а
второе — другой. Необходимо поменять значения переменных так, чтобы значение первой оказалось во второй, а второй — в первой;

## 11. 

> `task_11{.py|c}`

Найти номер минимального элемента массива. Например, в массиве [10, -3, -
5, 2, 5] номер минимального элемента;

## 12.

> `task_12{.py|c}`

Переведите число, введенное пользователем, в байты или килобайты в
зависимости от его выбора. В данном задании вам нужно будет создать функции, для
перевода из килобайтов в байты и из байтов в килобайты. 

## 13. 

> `task_13{.py|c}`

Создайте программу, которая просит пользователя ввести свое имя и возраст. Распечатайте адресованное им послание, в котором будет указан год, в котором им исполнится 100 лет.

## 14.

>`task_14{.py|c}`

Напечатайте месяц из календаря по заданному начальному дню и количеству дней. Ваш ответ должен выглядеть примерно так:

```undefined
                   1
 2  3  4  5  6  7  8
 9 10 11 12 13 14 15
16 17 18 19 20 21 22
23 24 25 26 27 28 29
30 31
```

## 15.

> task_15{.py|c}

Напишите программу, выводящую количество дней в месяце по заданному номеру месяца и году.

### Формат ввода

На вход программе подается два целых положительных числа: номер месяца (от 1 до 12) и четырёхзначный год.

### Формат вывода

Необходимо вывести одно число — количество дней в заданном месяце.

#### Пример 1

Ввод

```
1 2001
```

Вывод

```
31
```

#### Пример 2

Ввод

```
2 2001
```

Вывод

```
28
```


## 16.

> task_16{.py|c}

На мероприятие приглашены $n$ гостей. Им предлагают занять места с номерами от $1$ до $n$ в зале. Гости занимают эти места в произвольном порядке. Известно, на каком месте сел очередной гость.

Выпишите для каждого очередного места номер гостя, который на него сел.

### Формат ввода

Дано число nn, а затем nn различных чисел $a1,a2,...,a_n$ ​ от $1$ до $n$. Число $ak$​ — это номер места, на которое сел $k$-й гость.

Число $n$ не превосходит $20000$.

### Формат вывода

Выведите $n$ чисел $b1​,b2​,...,b_n$​ от $1$ до $n$. Число $bk$​ должно обозначать номер гостя, который сел на $k$-е место.

#### Пример 1

Ввод

```
5
1 2 3 5 4
```

Вывод

```
1 2 3 5 4 
```

#### Пример 2

Ввод

```
11
11 6 8 2 10 9 4 7 3 1 5
```

Вывод

```
10 4 9 7 11 2 8 3 6 5 1 
```

# Балльные задания

> Нужно набрать 20 баллов


## 10. Черепашьи бега (C)

> `tortoise_racing.c`

У нас есть две черепахи:
*   **Черепаха A** (ленивая): Уползает со скоростью `v1` футов в час. У неё фора в `g` футов.
*   **Черепаха B** (голодная): Бежит со скоростью `v2` футов в час. Она хочет догнать A и вернуться к своей капусте.

Вопрос: **Через какое время B догонит A?**

Самое важное: если `v1` >= `v2`, то жадная черепашака никогда не догонит ленивую. Это же очевидно! В этом случае мы возвращаем `nil` (или что-то подобное, в зависимости от языка).

Так, смотрите, вся хитрость не в физике, а в *относительной скорости*. Представьте, что черепаха A стоит на месте (просто потому что нам так удобно!). Тогда с какой скоростью к ней приближается черепаха B?
Правильно! Со скоростью `v2 - v1` футов в час.

А расстояние между ними в этот момент? Именно `g` футов.

**Время = Расстояние / Скорость**

Итак, общее время в часах, которое потребуется B, чтобы догнать A, это:
`t = g / (v2 - v1)`

Всё! Задача решена. Но нет! Время `t` у нас получится дробным (например, 0.538456 часов), а нам нужно представить его в виде **[часы, минуты, секунды]**, отбросив доли секунды.

Давайте проверим на примере `race(720, 850, 70)`:

1.  `t = 70 / (850 - 720) = 70 / 130 ≈ 0.538461538 часов`
2.  **Часы:** `floor(0.538461538) = 0`
3.  **Минуты:** `0.538461538 * 60 ≈ 32.30769228`
4.  **Целые минуты:** `floor(32.30769228) = 32`
5.  **Секунды:** `(32.30769228 - 32) * 60 ≈ 0.30769228 * 60 ≈ 18.4615368`
6.  **Целые секунды:** `floor(18.4615368) = 18`

Получаем `[0, 32, 18]`. Сошлось!

**Предупреждение!** В коде нужно быть осторожным с целочисленным делением и преобразованиями. Лучше работать с плавающей точкой, а потом брать целые части. И не забыть краевой случай с `v1 >= v2`!


```c
#include <stdlib.h>
#include <math.h>

int* race(int v1, int v2, int g) 
{
   int* time = malloc(3 * sizeof(int));
   return time;
}


static int arrays_equal(const int *a, const int *b, size_t n) {
    for (size_t i = 0; i < n; i++) {
        if (a[i] != b[i]) return 0;
    }
    return 1;
}

static void do_test(int v1, int v2, int g, const int expected[3], int test_num) {
    int *actual = race(v1, v2, g);
    
    if (!arrays_equal(actual, expected, 3)) {
        free(actual);
        exit(test_num); // Возвращаем номер проваленного теста
    }
    
    free(actual);
}

int main() {
    do_test(720, 850, 70, (int[]){0, 32, 18}, 1);
    do_test(820, 81, 550, (int[]){-1, -1, -1}, 2);
    do_test(80, 91, 37, (int[]){3, 21, 49}, 3);
    do_test(80, 100, 40, (int[]){2, 0, 0}, 4);
    do_test(720, 850, 37, (int[]){0, 17, 4}, 5);
    do_test(720, 850, 370, (int[]){2, 50, 46}, 6);
    do_test(120, 850, 37, (int[]){0, 3, 2}, 7);
    do_test(820, 850, 550, (int[]){18, 20, 0}, 8);
    do_test(82, 50, 55, (int[]){-1, -1, -1}, 9);
    
    return 0; 
}
```


##  10. Преобразование в Стиль Джейдена Смита (Python)

> `jaden.py`

Смотрите, в чём тут дело. На входе у нас обычная строка, например:
`"How can mirrors be real if our eyes aren't real"`

А на выходе мы должны получить:
`"How Can Mirrors Be Real If Our Eyes Aren't Real"`

Видите? Первая буква каждого слова стала заглавной, а все остальные — строчными.

Но давайте посмотрим на пример с апострофом: `"aren't"`.
*   Глупый алгоритм мог бы сделать `"Aren'T"`, потому что увидел бы букву `'t'` после апострофа и тоже захотел бы её capitalize.
*   Но умный алгоритм, который использует встроенную функцию `capitalize()` (или её аналог в вашем языке), сделает правильно: `"Aren't"`. Потому что стандартные функции обычно обрабатывают только первый символ слова.

Вот вам и ответ! Получилась строка в стиле Джейдена Смита.


```c
	do_test(
		"",
		""
	);
	do_test(
		"How can mirrors be real if our eyes aren't real",
		"How Can Mirrors Be Real If Our Eyes Aren't Real"
	);
	do_test(
		"All the rules in this world were made by someone no smarter than you. So make your own.",
		"All The Rules In This World Were Made By Someone No Smarter Than You. So Make Your Own."
	);
	do_test(
		"School is the tool to brainwash the youth.",
		"School Is The Tool To Brainwash The Youth."
	);
	do_test(
		"If everybody in the world dropped out of school we would have a much more intelligent society.",
		"If Everybody In The World Dropped Out Of School We Would Have A Much More Intelligent Society."
	);
	do_test(
		"Dying is mainstream",
		"Dying Is Mainstream"
	);
	do_test(
		"If there is bread winners, there is bread losers. But you can't toast what isn't real.",
		"If There Is Bread Winners, There Is Bread Losers. But You Can't Toast What Isn't Real."
	);
	do_test(
		"When you Live your Whole life In a Prison freedom Can be So dull.",
		"When You Live Your Whole Life In A Prison Freedom Can Be So Dull."
	);
	do_test(
		"The moment that truth is organized it becomes a lie.",
		"The Moment That Truth Is Organized It Becomes A Lie."
	);
	do_test(
		"Pay attention to the numbers in your life they are vastly important.",
		"Pay Attention To The Numbers In Your Life They Are Vastly Important."
	);
	do_test(
		"If a book store never runs out of a certain book, dose that mean that nobody reads it, or everybody reads it",
		"If A Book Store Never Runs Out Of A Certain Book, Dose That Mean That Nobody Reads It, Or Everybody Reads It"
	);
```


## 10. Возвести каждую цифру в квадрат и склеить (C)

> `square_digits.c`

Итак, у нас на входе целое число. Например, `9119`. Нам нужно:
1.  Разобрать его на отдельные цифры: `9`, `1`, `1`, `9`.
2.  Каждую цифру возвести в квадрат: $9^2 = 81, 1^2 = 1, 1^2 = 1, 9^2 = 81$.
3.  Получившиеся результаты **склеить** вместе в одно новое число: `81` + `1` + `1` + `81` = `811181`.

Вот и всё! Из `9119` получился `811181`.

Поэтому самый простой путь:
1.  Превратить число в строку. Почему? Со строкой легко работать посимвольно!
    `9119` -> `"9119"`
2.  Пройтись по каждому символу (цифре) в этой строке:
    *   Взять символ `'9'`
    *   Превратить его обратно в цифру `9` (чтобы можно было возвести в квадрат)
    *   Возвести в квадрат: `9 * 9 = 81`
    *   Получившийся результат снова превратить в строку `"81"`
3.  По мере прохода по строке, мы будем собирать эти маленькие строки-квадраты в одну большую строку.
    `"81" + "1" + "1" + "81" = "811181"`
4.  Финальный шаг — взять эту большую строку и превратить её обратно в целое число!
    `"811181"` -> `811181`

```c
#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

unsigned long long square_digits(unsigned n) {
    unsigned long long result = 0;
    //
    return result;
}

static void do_test(unsigned n, unsigned long long expected, int test_num) {
    unsigned long long actual = square_digits(n);
    
    if (actual != expected) {
        exit(test_num); 
    }
}

int main() {
    do_test(3212u, 9414ull, 1);
    do_test(2112u, 4114ull, 2);
    do_test(0u, 0ull, 3);
    do_test(999u, 818181ull, 4);
    do_test(10001u, 10001ull, 5);
    do_test(3210987654u, 9410816449362516ull, 6);
    do_test(3999999999u, 9818181818181818181ull, 7);
    do_test(UINT_MAX, 164811681364948125ull, 8);
    
    return 0; 
}
```


О, классическая задачка! Я её обожаю. Она идеально подходит для того, чтобы проиллюстрировать красоту простого решения.

## 10. Сумма кратных 3 или 5 (Python)

> `mult_3_or_5.py`

Давайте разберём условие:
*   У нас есть любое число (скажем, `number`).
*   Нам нужно найти сумму всех натуральных чисел, которые:
    1.  Меньше этого `number`
    2.  И являются кратными либо 3, либо 5 (либо и тому, и другому одновременно).
*   **Важно:** Если число кратно и 3, и 5 (например, 15), мы должны посчитать его только один раз.
*   **На всякий случай:** Если нам подсунули отрицательное число, просто возвращаем 0.

Пример для `number = 10`:
Числа меньше 10, кратные 3 или 5: `3, 5, 6, 9`.
Их сумма: `3 + 5 + 6 + 9 = 23`.

```
def mult_3_or_5(number):   
    return

def test():
    test_cases = [
        (3, 0),    # Test 1
        (4, 3),    # Test 2
        (5, 3),    # Test 3
        (6, 8),    # Test 4
        (7, 14),   # Test 5
        (10, 23),  # Test 6
        (20, 78),   # Test 7
        (10, 23)   # Test 8
    ]
    
    for i, (input_num, expected) in enumerate(test_cases, 1):
        try:
            result = mult_3_or_5(input_num)
            if result != expected:
                exit(i) 
        except Exception:
            exit(i)
    
    return True  

if __name__ == "__main__":
	test()
    exit(0)
```

## 10. Разность двух списков (C)

> `diff_two_list.c`

У нас есть два списка: `a` и `b`.
Нам нужно из списка `a` удалить **все** элементы, которые есть в списке `b`. При этом порядок оставшихся элементов в `a` должен остаться таким же, как и был.

**Примеры, чтобы прояснить:**
*   `a = [1, 2]`, `b = [1]` **->** Результат: `[2]` (Удалили одну единицу)
*   `a = [1, 2, 2, 2, 3]`, `b = [2]` -> Результат: `[1, 3]` (Удалили все тройки двойки, а не только одну!)
*   `a = [1, 2, 3]`, `b = [4, 5]` -> Результат: `[1, 2, 3]` (Нечего удалять)
*   `a = [1, 2, 3]`, `b = []` -> Результат: `[1, 2, 3]` (Второй список пустой, удалять нечего)

Так, смотрите. Самое главное здесь — слово **"все вхождения"**. Если в списке `b` есть элемент `2`, то из списка `a` должны исчезнуть все двойки, а не только первая попавшаяся.

Самый простой и понятный способ — это пройтись по всем элементам списка `a` и для каждого элемента спросить: "А нет ли тебя в списке `b`?".

*   Если элемента в `b` **нет** — замечательно! Мы оставляем его в результате.
*   Если элемент в `b` **есть** — мы его пропускаем и не включаем в результат.

**Но есть нюанс!** Если мы будем для каждого элемента `a` проверять его наличие в `b` методом `element in b`, то при больших списках это может быть медленно (потому что проверка `in` для списка — это операция, которая в худшем случае просматривает весь список `b`).

Мы сохранили порядок элементов из `a` и удалили все вхождения элементов из `b`.

```с
#include <stdlib.h>

int *array_diff(const int *arr1, size_t n1, const int *arr2, size_t n2, size_t *z) {
    return 0;
}

static int arrays_equal(const int *a, const int *b, size_t n) {
    for (size_t i = 0; i < n; i++) {
        if (a[i] != b[i]) return 0;
    }
    return 1;
}

static void test_case(const int *arr1, size_t n1, const int *arr2, size_t n2, 
                     const int *expected, size_t expected_len, int test_num) {
    size_t z;
    int *result = array_diff(arr1, n1, arr2, n2, &z);
    
    if (z != expected_len || !arrays_equal(result, expected, z)) {
        exit(test_num); // Возвращаем номер проваленного теста
    }
    
    free(result);
}

int main() {
    {
        const int arr1[2] = {1, 2};
        const int arr2[1] = {1};
        const int expected[1] = {2};
        test_case(arr1, 2, arr2, 1, expected, 1, 1);
    }

    {
        const int arr1[3] = {1, 2, 2};
        const int arr2[1] = {1};
        const int expected[2] = {2, 2};
        test_case(arr1, 3, arr2, 1, expected, 2, 2);
    }
    {
        const int arr1[3] = {1, 2, 2};
        const int arr2[1] = {2};
        const int expected[1] = {1};
        test_case(arr1, 3, arr2, 1, expected, 1, 3);
    }
    {
        const int arr1[3] = {1, 2, 3};
        const int arr2[3] = {1, 2, 3};
        const int expected[1] = {3};
        test_case(arr1, 3, arr2, 2, expected, 1, 4);
    }
    {
        const int arr1[3] = {1, 2, 2};
        const int arr2[0] = {};
        const int expected[3] = {1, 2, 2};
        test_case(arr1, 3, arr2, 0, expected, 3, 5);
    }
    {
        const int arr1[0] = {};
        const int arr2[2] = {1, 2};
        const int expected[0] = {};
        test_case(arr1, 0, arr2, 2, expected, 0, 6);
    }
    {
        const int arr1[5] = {1, 2, 3, 4, 5};
        const int arr2[3] = {1, 3, 4};
        const int expected[2] = {2, 5};
        test_case(arr1, 5, arr2, 3, expected, 2, 7);
    }
    return 0; 
}
```


## 10. Сумма чётных чисел Фибоначчи (Python)

Смотрите, у нас есть последовательность Фибоначчи. Она начинается с 1 и 2 (иногда начинают с 1 и 1, но здесь именно так!), а каждое следующее число — это сумма двух предыдущих.

$$F_0 = 0, \space F_1 = 1$$
$$F_n = F_{n-1} + F_{n-2}$$


Нам нужно:

1. Сгенерировать все числа Фибоначчи, которые **не превышают четыре миллиона** (4,000,000).
2. Из этих чисел выбрать только **чётные**.
3. Найти **сумму** этих чётных чисел.

```python
def evenFibSum(limit):
	return result 

def test():
    test_cases = [
        (13, 10),      # Test 1
        (34, 44),      # Test 2  
        (100, 44),     # Test 3
        (200, 188),    # Test 4
        (10000, 3382), # Test 5
        (4000000, 4613732) # Test 6
    ]
    
    for i, (limit, expected) in enumerate(test_cases, 1):
        try:
            result = evenFibSum(limit)
            if result != expected:
                exit(i)
        except Exception:
            exit(i)
    
    return True

if __name__ == "__main__":
    test()
    exit(0)
```