# Тест 2

**Дата проведения тестирования**: 29 октября 2025 года.

**Продолжительность мероприятия**: с 9:00 до 10:15, что составляет 1 час 15 минут.

---
## Билет 1
# Стек

Вам необходимо реализовать класс `Stack`, который будет представлять собой стек. Стек — это структура данных, работающая по принципу "последний пришёл — первый вышел" (LIFO).

**Класс `Stack`**:

- Реализуйте класс `Stack`, который будет содержать следующие методы:
    - `__init__(self)`: инициализирует пустой стек.
    - `is_empty(self)`: возвращает `True`, если стек пуст, и `False` в противном случае.
    - `push(self, item)`: добавляет элемент на верх стека.
    - `pop(self)`: удаляет и возвращает верхний элемент стека. Если стек пуст, должно вызываться исключение `IndexError` (или `Exception`).
    - `peek(self)`: возвращает верхний элемент стека, не удаляя его. Если стек пуст, должно вызываться исключение `IndexError` (или `Exception`).
    - `size(self)`: возвращает количество элементов в стеке.

# Не такая уж случайность

Вы — маг. Вы собираетесь выполнить фокус.

В вашей волшебной шляпе находится `b` черных и w белых шаров, а также у вас есть **неограниченный запас шаров обоих цветов**.

Вы просите аудиторию повторно удалять из шляпы по **два шара**, и после каждой удаленной пары вы добавляете один шар по следующему правилу:

1. **Если удаленные шары одного цвета, вы добавляете белый шар**.

2. **Если удаленные шары разного цвета, вы добавляете черный шар**.

Фокус заключается в предсказании цвета последнего оставшегося шара.
```python
    notSoRandom(1,1)->"Black"
    notSoRandom(2,1)->"White"
    notSoRandom(1,2)->"Black"
    notSoRandom(2,2)->"White"
    notSoRandom(6,9)->"White"
```

# Задача о рюкзаке

У вас есть рюкзак ограниченной вместимости и список предметов с весами и стоимостями. Найдите максимальную стоимость предметов, которые можно уложить в рюкзак.

**Формат ввода**
Первая строка содержит два числа: `n` (количество предметов) и `capacity` (вместимость).
Следующие `n` строк содержат по два числа: вес и стоимость предмета.

**Формат вывода**
Выведите одно число — максимальную стоимость.

```task
In:
3 5
2 10
3 15
5 30

Out:
30

In:
6 10
2 10
3 15
5 30
7 20
1 5
4 10

Out:
50
```

# **Уникальные элементы с сохранением порядка**

Реализуйте функцию `unique_in_order`, которая принимает последовательность и возвращает список элементов, удалив повторяющиеся подряд элементы, сохранив исходный порядок.


```text
"AAAABBBCCDAABBB" -> ['A','B','C','D','A','B']  
"ABBCcAD" -> ['A','B','C','c','A','D']  
[1,2,2,3,3] -> [1,2,3]
```

## Билет 2
# Стек

Вам необходимо реализовать класс `Stack`, который будет представлять собой стек. Стек — это структура данных, работающая по принципу "последний пришёл — первый вышел" (LIFO).

**Класс `Stack`**:

- Реализуйте класс `Stack`, который будет содержать следующие методы:
    - `__init__(self)`: инициализирует пустой стек.
    - `is_empty(self)`: возвращает `True`, если стек пуст, и `False` в противном случае.
    - `push(self, item)`: добавляет элемент на верх стека.
    - `pop(self)`: удаляет и возвращает верхний элемент стека. Если стек пуст, должно вызываться исключение `IndexError` (или `Exception`).
    - `peek(self)`: возвращает верхний элемент стека, не удаляя его. Если стек пуст, должно вызываться исключение `IndexError` (или `Exception`).
    - `size(self)`: возвращает количество элементов в стеке.

# Пути в сетке

У вас есть сетка с m строками и n столбцами. Верните количество уникальных путей из верхнего левого угла в нижний правый угол. Разрешенные движения: только вправо и вниз.

Например, в сетке ниже с 3 строками и 4 столбцами существует 10 уникальных путий:

```text
o--o--o--o
|  |  |  |
o--o--o--o
|  |  |  |
o--o--o--o
```

Примечание: в тестах встречаются сетки размером до 1000×1000, поэтому наивное решение не подойдет

# Похожие названия 

Пара слов интересная, если слова отличаются ровно в одной букве.

Дан набор слов одинаковой длины. Вычислите количество интересных пар.

**Формат ввода**  
Первая строка содержит одно число n — количество слов.  
Далее следуют n строк, каждая содержит ровно одну непустую строку, состоящую из не более чем 10 символов английского алфавита. Символы могут быть верхнего и нижнего регистра.

**Формат вывода**  
Вывод должен содержать одно число — количество интересных пар слов.

**Пример:**
```
In:
3
abc
abd
bbc

Out:
2
```

# **Проверка маршрута прогулки**

Город Картезия имеет идеальную сетку улиц. Вы всегда проходите 1 блок за 1 минуту. Функция должна вернуть `true`, если предложенный маршрут:
- Занимает ровно 10 минут.
- Возвращает вас в начальную точку.

**Примечание:** Маршрут состоит из символов `'n'`, `'s'`, `'e'`, `'w'`. Массив не пуст.

**Примеры тестов:**
```text
is_valid_walk(['n','s','n','s','n','s','n','s','n','s']) -> True  
is_valid_walk(['w','e','w','e','w','e','w','e','w','e','w','e']) -> False  
is_valid_walk(['w']) -> False  
is_valid_walk(['n','n','n','s','n','s','n','s','n','s']) -> False
```

## Билет 3
# Двухсвязный список

Вам необходимо реализовать класс для представления узла двухсвязного списка и сам двухсвязный список. Двухсвязный список — это структура данных, в которой каждый узел содержит данные и ссылки на следующий и предыдущий узлы.

- **Класс `Node`**:

    - Реализуйте класс `Node`, который будет представлять узел двухсвязного списка. Узел должен содержать:
        - `data`: данные узла (может быть любого типа).
        - `next`: ссылка на следующий узел (по умолчанию `None`).
        - `prev`: ссылка на предыдущий узел (по умолчанию `None`).

- **Класс `DoublyLinkedList`**:
    
    - Реализуйте класс `DoublyLinkedList`, который будет предоставлять методы для работы с двухсвязным списком:
        - `append(data)`: добавляет новый узел в конец списка.
        - `prepend(data)`: добавляет новый узел в начало списка.
        - `delete(data)`: удаляет первый узел, содержащий заданные данные.
        - `display()`: выводит элементы списка от начала до конца.
        - `display_reverse()`: выводит элементы списка от конца до начала.

# Не такая уж случайность

Вы — маг. Вы собираетесь выполнить фокус.

В вашей волшебной шляпе находится `b` черных и w белых шаров, а также у вас есть **неограниченный запас шаров обоих цветов**.

Вы просите аудиторию повторно удалять из шляпы по **два шара**, и после каждой удаленной пары вы добавляете один шар по следующему правилу:

1. **Если удаленные шары одного цвета, вы добавляете белый шар**.

2. **Если удаленные шары разного цвета, вы добавляете черный шар**.

Фокус заключается в предсказании цвета последнего оставшегося шара.
```python
    notSoRandom(1,1)->"Black"
    notSoRandom(2,1)->"White"
    notSoRandom(1,2)->"Black"
    notSoRandom(2,2)->"White"
    notSoRandom(6,9)->"White"
```

# Похожие названия 

Пара слов интересная, если слова отличаются ровно в одной букве.

Дан набор слов одинаковой длины. Вычислите количество интересных пар.

**Формат ввода**  
Первая строка содержит одно число n — количество слов.  
Далее следуют n строк, каждая содержит ровно одну непустую строку, состоящую из не более чем 10 символов английского алфавита. Символы могут быть верхнего и нижнего регистра.

**Формат вывода**  
Вывод должен содержать одно число — количество интересных пар слов.

**Пример:**
```
In:
3
abc
abd
bbc

Out:
2
```

# **Кодирование дубликатов**

Необходимо преобразовать строку в новую строку, где каждый символ заменяется на `"("`, если он встречается в исходной строке только один раз, и на `")"`, если он встречается более одного раза. Регистр символов при определении дубликатов игнорируется.


```text
"din"      -> "((("  
"recede"   -> "()()()"  
"Success"  -> ")())())"  
"(( @"     -> "))(("
```

**Примечание:** В описаниях задач может упоминаться `"XXX"` как ожидаемый результат, а не входные данные.

## Билет 4
# Приоритетная Очередь

Вам необходимо реализовать приоритетную очередь с использованием собственного алгоритма. Эта очередь будет хранить элементы с приоритетами и обеспечивать доступ к элементам с наивысшим приоритетом.

**Класс `PriorityQueue`**:

- Реализуйте класс `PriorityQueue`, который будет содержать следующие методы:
    - `__init__(self)`: инициализирует пустую приоритетную очередь.
    - `push(self, item, priority)`: добавляет элемент с заданным приоритетом в очередь.
    - `pop(self)`: удаляет и возвращает элемент с наивысшим приоритетом удаляет и возвращает элемент с наивысшим приоритетом. Наивысший приоритет соответствует наибольшему числовому значению `priority`.
    - `peek(self)`: возвращает элемент с наивысшим приоритетом, не удаляя его.
    - `is_empty(self)`: возвращает `True`, если очередь пуста, иначе — `False`.
    - `size(self)`: возвращает количество элементов в очереди.

# Сумма регулярных чисел

Вам дан обычный массив `arr`. Назовем "шагом" разность между двумя соседними элементами.

Ваша задача — просуммировать элементы, принадлежащие последовательностям из как минимум 3 последовательных элементов, в которых шаг между элементами постоянен. Последовательности должны быть максимально возможной длины.

Обратите внимание: некоторые элементы могут принадлежать двум последовательностям и должны учитываться дважды.

Пример:
Для `arr = [54, 70, 86, 1, -2, -5, 0, 5, 78, 145, 212, 15]` ответ равен 639.

В массиве 4 последовательности с постоянным шагом:

`{54, 70, 86}` с шагом `+16`

`{1, -2, -5}` с шагом `-3`

`{-5, 0, 5}` с шагом `+5`

`{78, 145, 212}` с шагом `+67`

Сумма: `(54+70+86) + (1-2-5) + (-5+0+5) + (78+145+212) = 639`

# Расширенная форма числа

Преобразуйте число в расширенную форму (например, 70304 → "70000 + 300 + 4").

**Формат ввода**
На вход подается одно целое положительное число.

**Формат вывода**
Выведите строку в расширенной форме.

```python
In: 12
Out: "10 + 2"

In: 70304
Out: "70000 + 300 + 4"
```

# **Сумма цифр и цифровой корень**

Цифровой корень — это рекурсивная сумма всех цифр числа.

Для заданного целого неотрицательного числа `n` необходимо вычислить сумму его цифр. Если полученное значение содержит более одной цифры, процедура повторяется до тех пор, пока не будет получено однозначное число. 


```text
16      -> 1 + 6 = 7  
942     -> 9 + 4 + 2 = 15 -> 1 + 5 = 6  
132189  -> 1 + 3 + 2 + 1 + 8 + 9 = 24 -> 2 + 4 = 6  
493193  -> 4 + 9 + 3 + 1 + 9 + 3 = 29 -> 2 + 9 = 11 -> 1 + 1 = 2
```

## Билет 5
# Приоритетная Очередь

Вам необходимо реализовать приоритетную очередь с использованием собственного алгоритма. Эта очередь будет хранить элементы с приоритетами и обеспечивать доступ к элементам с наивысшим приоритетом.

**Класс `PriorityQueue`**:

- Реализуйте класс `PriorityQueue`, который будет содержать следующие методы:
    - `__init__(self)`: инициализирует пустую приоритетную очередь.
    - `push(self, item, priority)`: добавляет элемент с заданным приоритетом в очередь.
    - `pop(self)`: удаляет и возвращает элемент с наивысшим приоритетом удаляет и возвращает элемент с наивысшим приоритетом. Наивысший приоритет соответствует наибольшему числовому значению `priority`.
    - `peek(self)`: возвращает элемент с наивысшим приоритетом, не удаляя его.
    - `is_empty(self)`: возвращает `True`, если очередь пуста, иначе — `False`.
    - `size(self)`: возвращает количество элементов в очереди.

# Бинарный поиск

Вам необходимо разработать функцию, которая будет искать элемент в отсортированном списке чисел. Для этого вы решили использовать метод бинарного поиска. Этот алгоритм позволяет эффективно находить элемент, деля список на две части.

- Алгоритм бинарного поиска работает только с отсортированными массивами.
- Он начинается с нахождения среднего элемента:
    - Если средний элемент равен искомому, возвращаем его индекс.
    - Если искомый элемент меньше среднего, продолжаем поиск в левой половине.
    - Если искомый элемент больше среднего, продолжаем поиск в правой половине.
- Если элемент не найден, функция должна вернуть `-1`.


```text
In: [1, 2, 3, 4, 5], 3
Out: 2

In: [1, 2, 3, 4, 5], 6
Out: -1
```

# Soundex

Известный алгоритм Soundex определяет, похожи ли два английских слова по звучанию. На вход он принимает слово и заменяет его на некоторый четырёхсимвольный код. Если коды двух слов совпадают, то слова, как правило, звучат похоже.

Вам требуется реализовать этот алгоритм. Он работает так:

1. Первая буква слова сохраняется.
2. В остальной части слова буквы a, e, h, i, o, u, w и y удаляются;
3. Оставшиеся буквы заменяются на цифры от 1 до 6, причём похожим по звучанию буквам соответствуют одинаковые цифры:
   - b, f, p, v: 1
   - c, g, j, k, q, s, x, z: 2
   - d, t: 3
   - l: 4
   - m, n: 5
   - r: 6
4. Любая последовательность идущих подряд одинаковых цифр сокращается до одной такой цифры.
5. Итоговая строка обрезается до первых четырёх символов.
6. Если длина строки получилась меньше четырёх символов, в конце добавляются нули.

**Примеры:**
- ammonium → ammnm → a5555 → a5 → a500
- implementation → implmnttn → i51455335 → i514535 → i514

# **Сортировка слов по числу в строке**

Необходимо отсортировать слова в строке, где каждое слово содержит ровно одну цифру от 1 до 9. Цифра указывает позицию слова в результате. Если строка пуста, вернуть пустую строку.


```text
"is2 Thi1s T4est 3a"               -> "Thi1s is2 3a T4est"  
"4of Fo1r pe6ople g3ood th5e the2" -> "Fo1r the2 g3ood 4of th5e pe6ople"  
""                                 -> ""
```

## Билет 6
# Стек

Вам необходимо реализовать класс `Stack`, который будет представлять собой стек. Стек — это структура данных, работающая по принципу "последний пришёл — первый вышел" (LIFO).

**Класс `Stack`**:

- Реализуйте класс `Stack`, который будет содержать следующие методы:
    - `__init__(self)`: инициализирует пустой стек.
    - `is_empty(self)`: возвращает `True`, если стек пуст, и `False` в противном случае.
    - `push(self, item)`: добавляет элемент на верх стека.
    - `pop(self)`: удаляет и возвращает верхний элемент стека. Если стек пуст, должно вызываться исключение `IndexError` (или `Exception`).
    - `peek(self)`: возвращает верхний элемент стека, не удаляя его. Если стек пуст, должно вызываться исключение `IndexError` (или `Exception`).
    - `size(self)`: возвращает количество элементов в стеке.

# Пути в сетке

У вас есть сетка с m строками и n столбцами. Верните количество уникальных путей из верхнего левого угла в нижний правый угол. Разрешенные движения: только вправо и вниз.

Например, в сетке ниже с 3 строками и 4 столбцами существует 10 уникальных путий:

```text
o--o--o--o
|  |  |  |
o--o--o--o
|  |  |  |
o--o--o--o
```

Примечание: в тестах встречаются сетки размером до 1000×1000, поэтому наивное решение не подойдет

# Обмены между массивами

Даны два массива `a` и `b`. За не более k обменов элементов между массивами, максимизируйте сумму массива `a`.

**Формат ввода**
Первая строка содержит три числа: `n`, `m` и `k` (длины массивов и максимальное количество обменов).
Вторая строка содержит `n` чисел — массив `a`.
Третья строка содержит `m` чисел — массив `b`.

**Формат вывода**
Выведите одно число — максимальную сумму массива `a` после обменов.

```python
In:
2 2 1
1 2
3 4

Out:
6
```

# **Кодирование дубликатов**

Необходимо преобразовать строку в новую строку, где каждый символ заменяется на `"("`, если он встречается в исходной строке только один раз, и на `")"`, если он встречается более одного раза. Регистр символов при определении дубликатов игнорируется.


```text
"din"      -> "((("  
"recede"   -> "()()()"  
"Success"  -> ")())())"  
"(( @"     -> "))(("
```

**Примечание:** В описаниях задач может упоминаться `"XXX"` как ожидаемый результат, а не входные данные.

## Билет 7
# Двухсвязный список

Вам необходимо реализовать класс для представления узла двухсвязного списка и сам двухсвязный список. Двухсвязный список — это структура данных, в которой каждый узел содержит данные и ссылки на следующий и предыдущий узлы.

- **Класс `Node`**:

    - Реализуйте класс `Node`, который будет представлять узел двухсвязного списка. Узел должен содержать:
        - `data`: данные узла (может быть любого типа).
        - `next`: ссылка на следующий узел (по умолчанию `None`).
        - `prev`: ссылка на предыдущий узел (по умолчанию `None`).

- **Класс `DoublyLinkedList`**:
    
    - Реализуйте класс `DoublyLinkedList`, который будет предоставлять методы для работы с двухсвязным списком:
        - `append(data)`: добавляет новый узел в конец списка.
        - `prepend(data)`: добавляет новый узел в начало списка.
        - `delete(data)`: удаляет первый узел, содержащий заданные данные.
        - `display()`: выводит элементы списка от начала до конца.
        - `display_reverse()`: выводит элементы списка от конца до начала.

# Сортировка колоды карт

Вы — раздающий на турнире по карточным играм, и ваша задача — отсортировать колоду карт. Колода состоит из карт с различными значениями, и вы хотите использовать алгоритм быстрой сортировки для упрощения процесса.

- Если в колоде менее четырех карт, вы должны просто упорядочить их и завершить работу.
- Если в колоде четыре или более карт:
    - Выберите наугад одну карту, которая будет служить опорной.
    - Разделите оставшиеся карты на две группы:
        - **Левая колода**: карты с меньшим значением, чем у опорной.
        - **Правая колода**: карты с большим значением.
- Проделайте ту же процедуру для каждой из новых колод.
- Объедините отсортированные левые карты, опорную карту и отсортированные правые карты, чтобы получить окончательную отсортированную колоду.

```text
In : [5, 2, 8, 1, 3]
Out: [1, 2, 3, 5, 8]
```

# Расширенная форма числа

Преобразуйте число в расширенную форму (например, 70304 → "70000 + 300 + 4").

**Формат ввода**
На вход подается одно целое положительное число.

**Формат вывода**
Выведите строку в расширенной форме.

```python
In: 12
Out: "10 + 2"

In: 70304
Out: "70000 + 300 + 4"
```

# **Реверс слов длиной более 5 символов**

Напишите функцию, которая принимает строку из одного или нескольких слов и возвращает её, развернув все слова **длиной пять и более символов**. Строка состоит только из букв и пробелов. Пробелы присутствуют только при наличии нескольких слов.


```text
"Hey fellow warriors"  -> "Hey wollef sroirraw"  
"This is a test"        -> "This is a test"  
"This is another test"  -> "This is rehtona test"
```

## Билет 8
# Очередь

Вам необходимо реализовать класс `Queue`, который будет представлять собой очередь. Очередь — это структура данных, работающая по принципу "первый пришёл — первый вышел" (FIFO).

**Класс `Queue`**:
- Реализуйте класс `Queue`, который будет содержать следующие методы:
    - `__init__(self)`: инициализирует пустую очередь.
    - `is_empty(self)`: возвращает `True`, если очередь пуста, и `False` в противном случае.
    - `enqueue(self, item)`: добавляет элемент в конец очереди.
    - `dequeue(self)`: удаляет и возвращает элемент из начала очереди. Если очередь пуста, необходимо вызвать исключение `IndexError` (или `Exception`).
    - `front(self)`: возвращает элемент из начала очереди без удаления. Если очередь пуста, необходимо вызвать исключение `IndexError` (или `Exception`).
    - `size(self)`: возвращает количество элементов в очереди.

# Сумма регулярных чисел

Вам дан обычный массив `arr`. Назовем "шагом" разность между двумя соседними элементами.

Ваша задача — просуммировать элементы, принадлежащие последовательностям из как минимум 3 последовательных элементов, в которых шаг между элементами постоянен. Последовательности должны быть максимально возможной длины.

Обратите внимание: некоторые элементы могут принадлежать двум последовательностям и должны учитываться дважды.

Пример:
Для `arr = [54, 70, 86, 1, -2, -5, 0, 5, 78, 145, 212, 15]` ответ равен 639.

В массиве 4 последовательности с постоянным шагом:

`{54, 70, 86}` с шагом `+16`

`{1, -2, -5}` с шагом `-3`

`{-5, 0, 5}` с шагом `+5`

`{78, 145, 212}` с шагом `+67`

Сумма: `(54+70+86) + (1-2-5) + (-5+0+5) + (78+145+212) = 639`

#  Пароли

Пароль от некоторого сервиса должен удовлетворять таким ограничениям:
- состоять из символов таблицы ASCII с кодами от 33 до 126;
- быть не короче 8 символов и не длиннее 14;
- из 4 классов символов — большие буквы, маленькие буквы, цифры, прочие символы — в пароле должны присутствовать не менее трёх любых.

Напишите программу, которая проверит, что введённый пароль подходит под эти ограничения.

**Пример:**
```
In: "Password123!"
Out: True

In: "abc123"
Out: False
```

# **Проверка маршрута прогулки**

Город Картезия имеет идеальную сетку улиц. Вы всегда проходите 1 блок за 1 минуту. Функция должна вернуть `true`, если предложенный маршрут:
- Занимает ровно 10 минут.
- Возвращает вас в начальную точку.

**Примечание:** Маршрут состоит из символов `'n'`, `'s'`, `'e'`, `'w'`. Массив не пуст.

**Примеры тестов:**
```text
is_valid_walk(['n','s','n','s','n','s','n','s','n','s']) -> True  
is_valid_walk(['w','e','w','e','w','e','w','e','w','e','w','e']) -> False  
is_valid_walk(['w']) -> False  
is_valid_walk(['n','n','n','s','n','s','n','s','n','s']) -> False
```

## Билет 9
# Стек

Вам необходимо реализовать класс `Stack`, который будет представлять собой стек. Стек — это структура данных, работающая по принципу "последний пришёл — первый вышел" (LIFO).

**Класс `Stack`**:

- Реализуйте класс `Stack`, который будет содержать следующие методы:
    - `__init__(self)`: инициализирует пустой стек.
    - `is_empty(self)`: возвращает `True`, если стек пуст, и `False` в противном случае.
    - `push(self, item)`: добавляет элемент на верх стека.
    - `pop(self)`: удаляет и возвращает верхний элемент стека. Если стек пуст, должно вызываться исключение `IndexError` (или `Exception`).
    - `peek(self)`: возвращает верхний элемент стека, не удаляя его. Если стек пуст, должно вызываться исключение `IndexError` (или `Exception`).
    - `size(self)`: возвращает количество элементов в стеке.

# Сумма регулярных чисел

Вам дан обычный массив `arr`. Назовем "шагом" разность между двумя соседними элементами.

Ваша задача — просуммировать элементы, принадлежащие последовательностям из как минимум 3 последовательных элементов, в которых шаг между элементами постоянен. Последовательности должны быть максимально возможной длины.

Обратите внимание: некоторые элементы могут принадлежать двум последовательностям и должны учитываться дважды.

Пример:
Для `arr = [54, 70, 86, 1, -2, -5, 0, 5, 78, 145, 212, 15]` ответ равен 639.

В массиве 4 последовательности с постоянным шагом:

`{54, 70, 86}` с шагом `+16`

`{1, -2, -5}` с шагом `-3`

`{-5, 0, 5}` с шагом `+5`

`{78, 145, 212}` с шагом `+67`

Сумма: `(54+70+86) + (1-2-5) + (-5+0+5) + (78+145+212) = 639`

# Похожие названия 

Пара слов интересная, если слова отличаются ровно в одной букве.

Дан набор слов одинаковой длины. Вычислите количество интересных пар.

**Формат ввода**  
Первая строка содержит одно число n — количество слов.  
Далее следуют n строк, каждая содержит ровно одну непустую строку, состоящую из не более чем 10 символов английского алфавита. Символы могут быть верхнего и нижнего регистра.

**Формат вывода**  
Вывод должен содержать одно число — количество интересных пар слов.

**Пример:**
```
In:
3
abc
abd
bbc

Out:
2
```

# **Сумма цифр и цифровой корень**

Цифровой корень — это рекурсивная сумма всех цифр числа.

Для заданного целого неотрицательного числа `n` необходимо вычислить сумму его цифр. Если полученное значение содержит более одной цифры, процедура повторяется до тех пор, пока не будет получено однозначное число. 


```text
16      -> 1 + 6 = 7  
942     -> 9 + 4 + 2 = 15 -> 1 + 5 = 6  
132189  -> 1 + 3 + 2 + 1 + 8 + 9 = 24 -> 2 + 4 = 6  
493193  -> 4 + 9 + 3 + 1 + 9 + 3 = 29 -> 2 + 9 = 11 -> 1 + 1 = 2
```

## Билет 10
# Приоритетная Очередь

Вам необходимо реализовать приоритетную очередь с использованием собственного алгоритма. Эта очередь будет хранить элементы с приоритетами и обеспечивать доступ к элементам с наивысшим приоритетом.

**Класс `PriorityQueue`**:

- Реализуйте класс `PriorityQueue`, который будет содержать следующие методы:
    - `__init__(self)`: инициализирует пустую приоритетную очередь.
    - `push(self, item, priority)`: добавляет элемент с заданным приоритетом в очередь.
    - `pop(self)`: удаляет и возвращает элемент с наивысшим приоритетом удаляет и возвращает элемент с наивысшим приоритетом. Наивысший приоритет соответствует наибольшему числовому значению `priority`.
    - `peek(self)`: возвращает элемент с наивысшим приоритетом, не удаляя его.
    - `is_empty(self)`: возвращает `True`, если очередь пуста, иначе — `False`.
    - `size(self)`: возвращает количество элементов в очереди.

# Не такая уж случайность

Вы — маг. Вы собираетесь выполнить фокус.

В вашей волшебной шляпе находится `b` черных и w белых шаров, а также у вас есть **неограниченный запас шаров обоих цветов**.

Вы просите аудиторию повторно удалять из шляпы по **два шара**, и после каждой удаленной пары вы добавляете один шар по следующему правилу:

1. **Если удаленные шары одного цвета, вы добавляете белый шар**.

2. **Если удаленные шары разного цвета, вы добавляете черный шар**.

Фокус заключается в предсказании цвета последнего оставшегося шара.
```python
    notSoRandom(1,1)->"Black"
    notSoRandom(2,1)->"White"
    notSoRandom(1,2)->"Black"
    notSoRandom(2,2)->"White"
    notSoRandom(6,9)->"White"
```

# Расширенная форма числа

Преобразуйте число в расширенную форму (например, 70304 → "70000 + 300 + 4").

**Формат ввода**
На вход подается одно целое положительное число.

**Формат вывода**
Выведите строку в расширенной форме.

```python
In: 12
Out: "10 + 2"

In: 70304
Out: "70000 + 300 + 4"
```

# **Реверс слов длиной более 5 символов**

Напишите функцию, которая принимает строку из одного или нескольких слов и возвращает её, развернув все слова **длиной пять и более символов**. Строка состоит только из букв и пробелов. Пробелы присутствуют только при наличии нескольких слов.


```text
"Hey fellow warriors"  -> "Hey wollef sroirraw"  
"This is a test"        -> "This is a test"  
"This is another test"  -> "This is rehtona test"
```

## Билет 11
# Приоритетная Очередь

Вам необходимо реализовать приоритетную очередь с использованием собственного алгоритма. Эта очередь будет хранить элементы с приоритетами и обеспечивать доступ к элементам с наивысшим приоритетом.

**Класс `PriorityQueue`**:

- Реализуйте класс `PriorityQueue`, который будет содержать следующие методы:
    - `__init__(self)`: инициализирует пустую приоритетную очередь.
    - `push(self, item, priority)`: добавляет элемент с заданным приоритетом в очередь.
    - `pop(self)`: удаляет и возвращает элемент с наивысшим приоритетом удаляет и возвращает элемент с наивысшим приоритетом. Наивысший приоритет соответствует наибольшему числовому значению `priority`.
    - `peek(self)`: возвращает элемент с наивысшим приоритетом, не удаляя его.
    - `is_empty(self)`: возвращает `True`, если очередь пуста, иначе — `False`.
    - `size(self)`: возвращает количество элементов в очереди.

# Пути в сетке

У вас есть сетка с m строками и n столбцами. Верните количество уникальных путей из верхнего левого угла в нижний правый угол. Разрешенные движения: только вправо и вниз.

Например, в сетке ниже с 3 строками и 4 столбцами существует 10 уникальных путий:

```text
o--o--o--o
|  |  |  |
o--o--o--o
|  |  |  |
o--o--o--o
```

Примечание: в тестах встречаются сетки размером до 1000×1000, поэтому наивное решение не подойдет

# Обмены между массивами

Даны два массива `a` и `b`. За не более k обменов элементов между массивами, максимизируйте сумму массива `a`.

**Формат ввода**
Первая строка содержит три числа: `n`, `m` и `k` (длины массивов и максимальное количество обменов).
Вторая строка содержит `n` чисел — массив `a`.
Третья строка содержит `m` чисел — массив `b`.

**Формат вывода**
Выведите одно число — максимальную сумму массива `a` после обменов.

```python
In:
2 2 1
1 2
3 4

Out:
6
```

# **Проверка маршрута прогулки**

Город Картезия имеет идеальную сетку улиц. Вы всегда проходите 1 блок за 1 минуту. Функция должна вернуть `true`, если предложенный маршрут:
- Занимает ровно 10 минут.
- Возвращает вас в начальную точку.

**Примечание:** Маршрут состоит из символов `'n'`, `'s'`, `'e'`, `'w'`. Массив не пуст.

**Примеры тестов:**
```text
is_valid_walk(['n','s','n','s','n','s','n','s','n','s']) -> True  
is_valid_walk(['w','e','w','e','w','e','w','e','w','e','w','e']) -> False  
is_valid_walk(['w']) -> False  
is_valid_walk(['n','n','n','s','n','s','n','s','n','s']) -> False
```

## Билет 12
# Очередь

Вам необходимо реализовать класс `Queue`, который будет представлять собой очередь. Очередь — это структура данных, работающая по принципу "первый пришёл — первый вышел" (FIFO).

**Класс `Queue`**:
- Реализуйте класс `Queue`, который будет содержать следующие методы:
    - `__init__(self)`: инициализирует пустую очередь.
    - `is_empty(self)`: возвращает `True`, если очередь пуста, и `False` в противном случае.
    - `enqueue(self, item)`: добавляет элемент в конец очереди.
    - `dequeue(self)`: удаляет и возвращает элемент из начала очереди. Если очередь пуста, необходимо вызвать исключение `IndexError` (или `Exception`).
    - `front(self)`: возвращает элемент из начала очереди без удаления. Если очередь пуста, необходимо вызвать исключение `IndexError` (или `Exception`).
    - `size(self)`: возвращает количество элементов в очереди.

# Сумма регулярных чисел

Вам дан обычный массив `arr`. Назовем "шагом" разность между двумя соседними элементами.

Ваша задача — просуммировать элементы, принадлежащие последовательностям из как минимум 3 последовательных элементов, в которых шаг между элементами постоянен. Последовательности должны быть максимально возможной длины.

Обратите внимание: некоторые элементы могут принадлежать двум последовательностям и должны учитываться дважды.

Пример:
Для `arr = [54, 70, 86, 1, -2, -5, 0, 5, 78, 145, 212, 15]` ответ равен 639.

В массиве 4 последовательности с постоянным шагом:

`{54, 70, 86}` с шагом `+16`

`{1, -2, -5}` с шагом `-3`

`{-5, 0, 5}` с шагом `+5`

`{78, 145, 212}` с шагом `+67`

Сумма: `(54+70+86) + (1-2-5) + (-5+0+5) + (78+145+212) = 639`

# Расширенная форма числа

Преобразуйте число в расширенную форму (например, 70304 → "70000 + 300 + 4").

**Формат ввода**
На вход подается одно целое положительное число.

**Формат вывода**
Выведите строку в расширенной форме.

```python
In: 12
Out: "10 + 2"

In: 70304
Out: "70000 + 300 + 4"
```

# **Поиск индекса с равными суммами сторон**

Дается массив целых чисел. Необходимо найти такой индекс `N`, чтобы сумма элементов слева от `N` была равна сумме элементов справа от `N`. Если такого индекса не существует, вернуть `-1`.


```text
[1,2,3,4,3,2,1]         -> 3 # (left: 1+2+3=6, right: 3+2+1=6)  
[1,100,50,-51,1,1]      -> 1 # (letf: 1, right: 50-51+1+1=1)  
[20,10,-80,10,10,15,35] -> 0 # (left: 0, right: 10-80+10+10+15+35=0)
```

## Билет 13
# Приоритетная Очередь

Вам необходимо реализовать приоритетную очередь с использованием собственного алгоритма. Эта очередь будет хранить элементы с приоритетами и обеспечивать доступ к элементам с наивысшим приоритетом.

**Класс `PriorityQueue`**:

- Реализуйте класс `PriorityQueue`, который будет содержать следующие методы:
    - `__init__(self)`: инициализирует пустую приоритетную очередь.
    - `push(self, item, priority)`: добавляет элемент с заданным приоритетом в очередь.
    - `pop(self)`: удаляет и возвращает элемент с наивысшим приоритетом удаляет и возвращает элемент с наивысшим приоритетом. Наивысший приоритет соответствует наибольшему числовому значению `priority`.
    - `peek(self)`: возвращает элемент с наивысшим приоритетом, не удаляя его.
    - `is_empty(self)`: возвращает `True`, если очередь пуста, иначе — `False`.
    - `size(self)`: возвращает количество элементов в очереди.

# Пути в сетке

У вас есть сетка с m строками и n столбцами. Верните количество уникальных путей из верхнего левого угла в нижний правый угол. Разрешенные движения: только вправо и вниз.

Например, в сетке ниже с 3 строками и 4 столбцами существует 10 уникальных путий:

```text
o--o--o--o
|  |  |  |
o--o--o--o
|  |  |  |
o--o--o--o
```

Примечание: в тестах встречаются сетки размером до 1000×1000, поэтому наивное решение не подойдет

# Похожие названия 

Пара слов интересная, если слова отличаются ровно в одной букве.

Дан набор слов одинаковой длины. Вычислите количество интересных пар.

**Формат ввода**  
Первая строка содержит одно число n — количество слов.  
Далее следуют n строк, каждая содержит ровно одну непустую строку, состоящую из не более чем 10 символов английского алфавита. Символы могут быть верхнего и нижнего регистра.

**Формат вывода**  
Вывод должен содержать одно число — количество интересных пар слов.

**Пример:**
```
In:
3
abc
abd
bbc

Out:
2
```

# **Кодирование дубликатов**

Необходимо преобразовать строку в новую строку, где каждый символ заменяется на `"("`, если он встречается в исходной строке только один раз, и на `")"`, если он встречается более одного раза. Регистр символов при определении дубликатов игнорируется.


```text
"din"      -> "((("  
"recede"   -> "()()()"  
"Success"  -> ")())())"  
"(( @"     -> "))(("
```

**Примечание:** В описаниях задач может упоминаться `"XXX"` как ожидаемый результат, а не входные данные.

## Билет 14
# Стек

Вам необходимо реализовать класс `Stack`, который будет представлять собой стек. Стек — это структура данных, работающая по принципу "последний пришёл — первый вышел" (LIFO).

**Класс `Stack`**:

- Реализуйте класс `Stack`, который будет содержать следующие методы:
    - `__init__(self)`: инициализирует пустой стек.
    - `is_empty(self)`: возвращает `True`, если стек пуст, и `False` в противном случае.
    - `push(self, item)`: добавляет элемент на верх стека.
    - `pop(self)`: удаляет и возвращает верхний элемент стека. Если стек пуст, должно вызываться исключение `IndexError` (или `Exception`).
    - `peek(self)`: возвращает верхний элемент стека, не удаляя его. Если стек пуст, должно вызываться исключение `IndexError` (или `Exception`).
    - `size(self)`: возвращает количество элементов в стеке.

# Причудливые квадраты

У числа 3025 есть замечательная особенность: если разделить его десятичное представление на две строки равных длин (30 и 25) и возведите в квадрат сумму полученных таким образом чисел, вы получите исходное число: $(30 + 25)^2 = 3025$

Задача состоит в том, чтобы определить все числа с этим свойством, имеющие заданное четное количество цифр. Например, четырехзначные числа имеют диапазон от 0000 до 9999. Обратите внимание, что ведущие нули следует брать в учетную запись.  Это означает, что $0001$ равно $(00 + 01)^2$  и это причудливое число из 4 цифр. Количество цифр может быть 2,4,6 или 8. Однако стоит задуматься об эффективности 

$$N = a_1 a_2 \ldots a_k a_{k+1} a_{k+2} \ldots a_{2k} $$
$$L = a_1 a_2 \ldots a_k $$
$$R = a_{k+1} a_{k+2} \ldots a_{2k} $$
$$(L + R)^2 = N$$

- $N$ — число с $2k$ цифрами.
- $L$ — левая часть из первых $k$ цифр.
- $R$ — правая часть из последних $k$ цифр.
- Условие, при котором число $N$ считается "причудливым".

Входные данные 
```text
2
```

Выходные данные
```text
00 
01 
81 
```

#  Пароли

Пароль от некоторого сервиса должен удовлетворять таким ограничениям:
- состоять из символов таблицы ASCII с кодами от 33 до 126;
- быть не короче 8 символов и не длиннее 14;
- из 4 классов символов — большие буквы, маленькие буквы, цифры, прочие символы — в пароле должны присутствовать не менее трёх любых.

Напишите программу, которая проверит, что введённый пароль подходит под эти ограничения.

**Пример:**
```
In: "Password123!"
Out: True

In: "abc123"
Out: False
```

# **Уникальные элементы с сохранением порядка**

Реализуйте функцию `unique_in_order`, которая принимает последовательность и возвращает список элементов, удалив повторяющиеся подряд элементы, сохранив исходный порядок.


```text
"AAAABBBCCDAABBB" -> ['A','B','C','D','A','B']  
"ABBCcAD" -> ['A','B','C','c','A','D']  
[1,2,2,3,3] -> [1,2,3]
```

## Билет 15
# Бинарное дерево

Вам необходимо реализовать класс для представления узла бинарного дерева и само бинарное дерево. Бинарное дерево — это структура данных, в которой каждый узел может иметь не более двух дочерних узлов, обычно называемых левым и правым.

1. **Класс `TreeNode`**:
    - Реализуйте класс `TreeNode`, который будет представлять узел бинарного дерева. Узел должен содержать:
        - `data`: данные узла (может быть любого типа).
        - `left`: ссылка на левое дочернее узло (по умолчанию `None`).
        - `right`: ссылка на правое дочернее узло (по умолчанию `None`).

2. **Класс `BinaryTree`**:
    
    - Реализуйте класс `BinaryTree`, который будет предоставлять методы для работы с бинарным деревом:
        - `insert(data)`: добавляет новый узел в дерево. Элементы меньшие корня - в левое поддерево, большие - в правоедобавляет новый узел в дерево. Элементы меньшие либо равные корню - в левое поддерево, большие - в правое.
        - `search(data)`: ищет узел с заданными данными и возвращает его, если он найден, или `None`, если не найден.
        - `in_order_traversal()`: выполняет обход дерева в симметричном порядке (левое, корень, правое).
        - `pre_order_traversal()`: выполняет обход дерева в префиксном порядке (корень, левое, правое).
        - `post_order_traversal()`: выполняет обход дерева в постфиксном порядке (левое, правое, корень).

# Причудливые квадраты

У числа 3025 есть замечательная особенность: если разделить его десятичное представление на две строки равных длин (30 и 25) и возведите в квадрат сумму полученных таким образом чисел, вы получите исходное число: $(30 + 25)^2 = 3025$

Задача состоит в том, чтобы определить все числа с этим свойством, имеющие заданное четное количество цифр. Например, четырехзначные числа имеют диапазон от 0000 до 9999. Обратите внимание, что ведущие нули следует брать в учетную запись.  Это означает, что $0001$ равно $(00 + 01)^2$  и это причудливое число из 4 цифр. Количество цифр может быть 2,4,6 или 8. Однако стоит задуматься об эффективности 

$$N = a_1 a_2 \ldots a_k a_{k+1} a_{k+2} \ldots a_{2k} $$
$$L = a_1 a_2 \ldots a_k $$
$$R = a_{k+1} a_{k+2} \ldots a_{2k} $$
$$(L + R)^2 = N$$

- $N$ — число с $2k$ цифрами.
- $L$ — левая часть из первых $k$ цифр.
- $R$ — правая часть из последних $k$ цифр.
- Условие, при котором число $N$ считается "причудливым".

Входные данные 
```text
2
```

Выходные данные
```text
00 
01 
81 
```

# Похожие названия 

Пара слов интересная, если слова отличаются ровно в одной букве.

Дан набор слов одинаковой длины. Вычислите количество интересных пар.

**Формат ввода**  
Первая строка содержит одно число n — количество слов.  
Далее следуют n строк, каждая содержит ровно одну непустую строку, состоящую из не более чем 10 символов английского алфавита. Символы могут быть верхнего и нижнего регистра.

**Формат вывода**  
Вывод должен содержать одно число — количество интересных пар слов.

**Пример:**
```
In:
3
abc
abd
bbc

Out:
2
```

# **Кодирование дубликатов**

Необходимо преобразовать строку в новую строку, где каждый символ заменяется на `"("`, если он встречается в исходной строке только один раз, и на `")"`, если он встречается более одного раза. Регистр символов при определении дубликатов игнорируется.


```text
"din"      -> "((("  
"recede"   -> "()()()"  
"Success"  -> ")())())"  
"(( @"     -> "))(("
```

**Примечание:** В описаниях задач может упоминаться `"XXX"` как ожидаемый результат, а не входные данные.

## Билет 16
# Двухсвязный список

Вам необходимо реализовать класс для представления узла двухсвязного списка и сам двухсвязный список. Двухсвязный список — это структура данных, в которой каждый узел содержит данные и ссылки на следующий и предыдущий узлы.

- **Класс `Node`**:

    - Реализуйте класс `Node`, который будет представлять узел двухсвязного списка. Узел должен содержать:
        - `data`: данные узла (может быть любого типа).
        - `next`: ссылка на следующий узел (по умолчанию `None`).
        - `prev`: ссылка на предыдущий узел (по умолчанию `None`).

- **Класс `DoublyLinkedList`**:
    
    - Реализуйте класс `DoublyLinkedList`, который будет предоставлять методы для работы с двухсвязным списком:
        - `append(data)`: добавляет новый узел в конец списка.
        - `prepend(data)`: добавляет новый узел в начало списка.
        - `delete(data)`: удаляет первый узел, содержащий заданные данные.
        - `display()`: выводит элементы списка от начала до конца.
        - `display_reverse()`: выводит элементы списка от конца до начала.

# Причудливые квадраты

У числа 3025 есть замечательная особенность: если разделить его десятичное представление на две строки равных длин (30 и 25) и возведите в квадрат сумму полученных таким образом чисел, вы получите исходное число: $(30 + 25)^2 = 3025$

Задача состоит в том, чтобы определить все числа с этим свойством, имеющие заданное четное количество цифр. Например, четырехзначные числа имеют диапазон от 0000 до 9999. Обратите внимание, что ведущие нули следует брать в учетную запись.  Это означает, что $0001$ равно $(00 + 01)^2$  и это причудливое число из 4 цифр. Количество цифр может быть 2,4,6 или 8. Однако стоит задуматься об эффективности 

$$N = a_1 a_2 \ldots a_k a_{k+1} a_{k+2} \ldots a_{2k} $$
$$L = a_1 a_2 \ldots a_k $$
$$R = a_{k+1} a_{k+2} \ldots a_{2k} $$
$$(L + R)^2 = N$$

- $N$ — число с $2k$ цифрами.
- $L$ — левая часть из первых $k$ цифр.
- $R$ — правая часть из последних $k$ цифр.
- Условие, при котором число $N$ считается "причудливым".

Входные данные 
```text
2
```

Выходные данные
```text
00 
01 
81 
```

# Задача о рюкзаке

У вас есть рюкзак ограниченной вместимости и список предметов с весами и стоимостями. Найдите максимальную стоимость предметов, которые можно уложить в рюкзак.

**Формат ввода**
Первая строка содержит два числа: `n` (количество предметов) и `capacity` (вместимость).
Следующие `n` строк содержат по два числа: вес и стоимость предмета.

**Формат вывода**
Выведите одно число — максимальную стоимость.

```task
In:
3 5
2 10
3 15
5 30

Out:
30

In:
6 10
2 10
3 15
5 30
7 20
1 5
4 10

Out:
50
```

# **Кодирование дубликатов**

Необходимо преобразовать строку в новую строку, где каждый символ заменяется на `"("`, если он встречается в исходной строке только один раз, и на `")"`, если он встречается более одного раза. Регистр символов при определении дубликатов игнорируется.


```text
"din"      -> "((("  
"recede"   -> "()()()"  
"Success"  -> ")())())"  
"(( @"     -> "))(("
```

**Примечание:** В описаниях задач может упоминаться `"XXX"` как ожидаемый результат, а не входные данные.

## Билет 17
# Приоритетная Очередь

Вам необходимо реализовать приоритетную очередь с использованием собственного алгоритма. Эта очередь будет хранить элементы с приоритетами и обеспечивать доступ к элементам с наивысшим приоритетом.

**Класс `PriorityQueue`**:

- Реализуйте класс `PriorityQueue`, который будет содержать следующие методы:
    - `__init__(self)`: инициализирует пустую приоритетную очередь.
    - `push(self, item, priority)`: добавляет элемент с заданным приоритетом в очередь.
    - `pop(self)`: удаляет и возвращает элемент с наивысшим приоритетом удаляет и возвращает элемент с наивысшим приоритетом. Наивысший приоритет соответствует наибольшему числовому значению `priority`.
    - `peek(self)`: возвращает элемент с наивысшим приоритетом, не удаляя его.
    - `is_empty(self)`: возвращает `True`, если очередь пуста, иначе — `False`.
    - `size(self)`: возвращает количество элементов в очереди.

# Не такая уж случайность

Вы — маг. Вы собираетесь выполнить фокус.

В вашей волшебной шляпе находится `b` черных и w белых шаров, а также у вас есть **неограниченный запас шаров обоих цветов**.

Вы просите аудиторию повторно удалять из шляпы по **два шара**, и после каждой удаленной пары вы добавляете один шар по следующему правилу:

1. **Если удаленные шары одного цвета, вы добавляете белый шар**.

2. **Если удаленные шары разного цвета, вы добавляете черный шар**.

Фокус заключается в предсказании цвета последнего оставшегося шара.
```python
    notSoRandom(1,1)->"Black"
    notSoRandom(2,1)->"White"
    notSoRandom(1,2)->"Black"
    notSoRandom(2,2)->"White"
    notSoRandom(6,9)->"White"
```

# Обмены между массивами

Даны два массива `a` и `b`. За не более k обменов элементов между массивами, максимизируйте сумму массива `a`.

**Формат ввода**
Первая строка содержит три числа: `n`, `m` и `k` (длины массивов и максимальное количество обменов).
Вторая строка содержит `n` чисел — массив `a`.
Третья строка содержит `m` чисел — массив `b`.

**Формат вывода**
Выведите одно число — максимальную сумму массива `a` после обменов.

```python
In:
2 2 1
1 2
3 4

Out:
6
```

# **Подсчёт повторяющихся символов**

Напишите функцию, которая возвращает количество **различных** символов (букв латинского алфавита и цифр), встречающихся в исходной строке более одного раза. Можно предположить, что строка содержит только буквы (в верхнем и нижнем регистре) и цифры.


```text
"abcde"             -> 0   #
"aabbcde"           -> 2   # 'a' and 'b'  
"aabBcde"           -> 2   # 'a' and 'b'   
"indivisibility"    -> 1   # 'i' 6 times  
"Indivisibilities"  -> 2   # 'i' and 's'  
"aA11"              -> 2   # 'a' and '1'  
"ABBA"              -> 2   # 'A' and 'B'
```

## Билет 18
# Двухсвязный список

Вам необходимо реализовать класс для представления узла двухсвязного списка и сам двухсвязный список. Двухсвязный список — это структура данных, в которой каждый узел содержит данные и ссылки на следующий и предыдущий узлы.

- **Класс `Node`**:

    - Реализуйте класс `Node`, который будет представлять узел двухсвязного списка. Узел должен содержать:
        - `data`: данные узла (может быть любого типа).
        - `next`: ссылка на следующий узел (по умолчанию `None`).
        - `prev`: ссылка на предыдущий узел (по умолчанию `None`).

- **Класс `DoublyLinkedList`**:
    
    - Реализуйте класс `DoublyLinkedList`, который будет предоставлять методы для работы с двухсвязным списком:
        - `append(data)`: добавляет новый узел в конец списка.
        - `prepend(data)`: добавляет новый узел в начало списка.
        - `delete(data)`: удаляет первый узел, содержащий заданные данные.
        - `display()`: выводит элементы списка от начала до конца.
        - `display_reverse()`: выводит элементы списка от конца до начала.

# Бинарный поиск

Вам необходимо разработать функцию, которая будет искать элемент в отсортированном списке чисел. Для этого вы решили использовать метод бинарного поиска. Этот алгоритм позволяет эффективно находить элемент, деля список на две части.

- Алгоритм бинарного поиска работает только с отсортированными массивами.
- Он начинается с нахождения среднего элемента:
    - Если средний элемент равен искомому, возвращаем его индекс.
    - Если искомый элемент меньше среднего, продолжаем поиск в левой половине.
    - Если искомый элемент больше среднего, продолжаем поиск в правой половине.
- Если элемент не найден, функция должна вернуть `-1`.


```text
In: [1, 2, 3, 4, 5], 3
Out: 2

In: [1, 2, 3, 4, 5], 6
Out: -1
```

#  Пароли

Пароль от некоторого сервиса должен удовлетворять таким ограничениям:
- состоять из символов таблицы ASCII с кодами от 33 до 126;
- быть не короче 8 символов и не длиннее 14;
- из 4 классов символов — большие буквы, маленькие буквы, цифры, прочие символы — в пароле должны присутствовать не менее трёх любых.

Напишите программу, которая проверит, что введённый пароль подходит под эти ограничения.

**Пример:**
```
In: "Password123!"
Out: True

In: "abc123"
Out: False
```

# **Сортировка слов по числу в строке**

Необходимо отсортировать слова в строке, где каждое слово содержит ровно одну цифру от 1 до 9. Цифра указывает позицию слова в результате. Если строка пуста, вернуть пустую строку.


```text
"is2 Thi1s T4est 3a"               -> "Thi1s is2 3a T4est"  
"4of Fo1r pe6ople g3ood th5e the2" -> "Fo1r the2 g3ood 4of th5e pe6ople"  
""                                 -> ""
```

## Билет 19
# Приоритетная Очередь

Вам необходимо реализовать приоритетную очередь с использованием собственного алгоритма. Эта очередь будет хранить элементы с приоритетами и обеспечивать доступ к элементам с наивысшим приоритетом.

**Класс `PriorityQueue`**:

- Реализуйте класс `PriorityQueue`, который будет содержать следующие методы:
    - `__init__(self)`: инициализирует пустую приоритетную очередь.
    - `push(self, item, priority)`: добавляет элемент с заданным приоритетом в очередь.
    - `pop(self)`: удаляет и возвращает элемент с наивысшим приоритетом удаляет и возвращает элемент с наивысшим приоритетом. Наивысший приоритет соответствует наибольшему числовому значению `priority`.
    - `peek(self)`: возвращает элемент с наивысшим приоритетом, не удаляя его.
    - `is_empty(self)`: возвращает `True`, если очередь пуста, иначе — `False`.
    - `size(self)`: возвращает количество элементов в очереди.

# Бинарный поиск

Вам необходимо разработать функцию, которая будет искать элемент в отсортированном списке чисел. Для этого вы решили использовать метод бинарного поиска. Этот алгоритм позволяет эффективно находить элемент, деля список на две части.

- Алгоритм бинарного поиска работает только с отсортированными массивами.
- Он начинается с нахождения среднего элемента:
    - Если средний элемент равен искомому, возвращаем его индекс.
    - Если искомый элемент меньше среднего, продолжаем поиск в левой половине.
    - Если искомый элемент больше среднего, продолжаем поиск в правой половине.
- Если элемент не найден, функция должна вернуть `-1`.


```text
In: [1, 2, 3, 4, 5], 3
Out: 2

In: [1, 2, 3, 4, 5], 6
Out: -1
```

# Рекурсивный рюкзак с мемоизацией

Реализуйте рекурсивное решение задачи о рюкзаке с мемоизацией для оптимизации.

**Формат ввода**
Первая строка содержит два числа: `n` (количество предметов) и `capacity` (вместимость).
Следующие `n` строк содержат по два числа: вес и стоимость предмета.

**Формат вывода**
Выведите одно число — максимальную стоимость.


```python
In:
5 7
2 5
3 8
5 15
1 3
4 10

Out:
18
```

# **Кодирование дубликатов**

Необходимо преобразовать строку в новую строку, где каждый символ заменяется на `"("`, если он встречается в исходной строке только один раз, и на `")"`, если он встречается более одного раза. Регистр символов при определении дубликатов игнорируется.


```text
"din"      -> "((("  
"recede"   -> "()()()"  
"Success"  -> ")())())"  
"(( @"     -> "))(("
```

**Примечание:** В описаниях задач может упоминаться `"XXX"` как ожидаемый результат, а не входные данные.

## Билет 20
# Приоритетная Очередь

Вам необходимо реализовать приоритетную очередь с использованием собственного алгоритма. Эта очередь будет хранить элементы с приоритетами и обеспечивать доступ к элементам с наивысшим приоритетом.

**Класс `PriorityQueue`**:

- Реализуйте класс `PriorityQueue`, который будет содержать следующие методы:
    - `__init__(self)`: инициализирует пустую приоритетную очередь.
    - `push(self, item, priority)`: добавляет элемент с заданным приоритетом в очередь.
    - `pop(self)`: удаляет и возвращает элемент с наивысшим приоритетом удаляет и возвращает элемент с наивысшим приоритетом. Наивысший приоритет соответствует наибольшему числовому значению `priority`.
    - `peek(self)`: возвращает элемент с наивысшим приоритетом, не удаляя его.
    - `is_empty(self)`: возвращает `True`, если очередь пуста, иначе — `False`.
    - `size(self)`: возвращает количество элементов в очереди.

# Не такая уж случайность

Вы — маг. Вы собираетесь выполнить фокус.

В вашей волшебной шляпе находится `b` черных и w белых шаров, а также у вас есть **неограниченный запас шаров обоих цветов**.

Вы просите аудиторию повторно удалять из шляпы по **два шара**, и после каждой удаленной пары вы добавляете один шар по следующему правилу:

1. **Если удаленные шары одного цвета, вы добавляете белый шар**.

2. **Если удаленные шары разного цвета, вы добавляете черный шар**.

Фокус заключается в предсказании цвета последнего оставшегося шара.
```python
    notSoRandom(1,1)->"Black"
    notSoRandom(2,1)->"White"
    notSoRandom(1,2)->"Black"
    notSoRandom(2,2)->"White"
    notSoRandom(6,9)->"White"
```

# Похожие названия 

Пара слов интересная, если слова отличаются ровно в одной букве.

Дан набор слов одинаковой длины. Вычислите количество интересных пар.

**Формат ввода**  
Первая строка содержит одно число n — количество слов.  
Далее следуют n строк, каждая содержит ровно одну непустую строку, состоящую из не более чем 10 символов английского алфавита. Символы могут быть верхнего и нижнего регистра.

**Формат вывода**  
Вывод должен содержать одно число — количество интересных пар слов.

**Пример:**
```
In:
3
abc
abd
bbc

Out:
2
```

# **Уникальные элементы с сохранением порядка**

Реализуйте функцию `unique_in_order`, которая принимает последовательность и возвращает список элементов, удалив повторяющиеся подряд элементы, сохранив исходный порядок.


```text
"AAAABBBCCDAABBB" -> ['A','B','C','D','A','B']  
"ABBCcAD" -> ['A','B','C','c','A','D']  
[1,2,2,3,3] -> [1,2,3]
```

## Билет 21
# Бинарное дерево

Вам необходимо реализовать класс для представления узла бинарного дерева и само бинарное дерево. Бинарное дерево — это структура данных, в которой каждый узел может иметь не более двух дочерних узлов, обычно называемых левым и правым.

1. **Класс `TreeNode`**:
    - Реализуйте класс `TreeNode`, который будет представлять узел бинарного дерева. Узел должен содержать:
        - `data`: данные узла (может быть любого типа).
        - `left`: ссылка на левое дочернее узло (по умолчанию `None`).
        - `right`: ссылка на правое дочернее узло (по умолчанию `None`).

2. **Класс `BinaryTree`**:
    
    - Реализуйте класс `BinaryTree`, который будет предоставлять методы для работы с бинарным деревом:
        - `insert(data)`: добавляет новый узел в дерево. Элементы меньшие корня - в левое поддерево, большие - в правоедобавляет новый узел в дерево. Элементы меньшие либо равные корню - в левое поддерево, большие - в правое.
        - `search(data)`: ищет узел с заданными данными и возвращает его, если он найден, или `None`, если не найден.
        - `in_order_traversal()`: выполняет обход дерева в симметричном порядке (левое, корень, правое).
        - `pre_order_traversal()`: выполняет обход дерева в префиксном порядке (корень, левое, правое).
        - `post_order_traversal()`: выполняет обход дерева в постфиксном порядке (левое, правое, корень).

# Сумма регулярных чисел

Вам дан обычный массив `arr`. Назовем "шагом" разность между двумя соседними элементами.

Ваша задача — просуммировать элементы, принадлежащие последовательностям из как минимум 3 последовательных элементов, в которых шаг между элементами постоянен. Последовательности должны быть максимально возможной длины.

Обратите внимание: некоторые элементы могут принадлежать двум последовательностям и должны учитываться дважды.

Пример:
Для `arr = [54, 70, 86, 1, -2, -5, 0, 5, 78, 145, 212, 15]` ответ равен 639.

В массиве 4 последовательности с постоянным шагом:

`{54, 70, 86}` с шагом `+16`

`{1, -2, -5}` с шагом `-3`

`{-5, 0, 5}` с шагом `+5`

`{78, 145, 212}` с шагом `+67`

Сумма: `(54+70+86) + (1-2-5) + (-5+0+5) + (78+145+212) = 639`

#  Пароли

Пароль от некоторого сервиса должен удовлетворять таким ограничениям:
- состоять из символов таблицы ASCII с кодами от 33 до 126;
- быть не короче 8 символов и не длиннее 14;
- из 4 классов символов — большие буквы, маленькие буквы, цифры, прочие символы — в пароле должны присутствовать не менее трёх любых.

Напишите программу, которая проверит, что введённый пароль подходит под эти ограничения.

**Пример:**
```
In: "Password123!"
Out: True

In: "abc123"
Out: False
```

# **Сумма цифр и цифровой корень**

Цифровой корень — это рекурсивная сумма всех цифр числа.

Для заданного целого неотрицательного числа `n` необходимо вычислить сумму его цифр. Если полученное значение содержит более одной цифры, процедура повторяется до тех пор, пока не будет получено однозначное число. 


```text
16      -> 1 + 6 = 7  
942     -> 9 + 4 + 2 = 15 -> 1 + 5 = 6  
132189  -> 1 + 3 + 2 + 1 + 8 + 9 = 24 -> 2 + 4 = 6  
493193  -> 4 + 9 + 3 + 1 + 9 + 3 = 29 -> 2 + 9 = 11 -> 1 + 1 = 2
```

## Билет 22
# Очередь

Вам необходимо реализовать класс `Queue`, который будет представлять собой очередь. Очередь — это структура данных, работающая по принципу "первый пришёл — первый вышел" (FIFO).

**Класс `Queue`**:
- Реализуйте класс `Queue`, который будет содержать следующие методы:
    - `__init__(self)`: инициализирует пустую очередь.
    - `is_empty(self)`: возвращает `True`, если очередь пуста, и `False` в противном случае.
    - `enqueue(self, item)`: добавляет элемент в конец очереди.
    - `dequeue(self)`: удаляет и возвращает элемент из начала очереди. Если очередь пуста, необходимо вызвать исключение `IndexError` (или `Exception`).
    - `front(self)`: возвращает элемент из начала очереди без удаления. Если очередь пуста, необходимо вызвать исключение `IndexError` (или `Exception`).
    - `size(self)`: возвращает количество элементов в очереди.

# Делимость подстроки

Число $1406357289$ является **панцифровым** числом от $0$ до $9$, поскольку оно состоит из каждой цифры от $0$ до $9$ в определенном порядке, но оно также обладает довольно интересным свойством делимости на подстроки.

Пусть $d_1$ — $1^{st}$ цифра, $d_2$ — $2^{nd}$ цифра и т.д. Таким образом, отметим следующее:

- $d_2d_3d_4=406$ делится на $2$
- $d_3d_4d_5=063$ делится на $3$
- $d_4d_5d_6=635$ делится на $5$
- $d_5d_6d_7=357$ делится на $7$
- $d_6d_7d_8=572$ делится на $11$
- $d_7d_8d_9=728$ делится на $13$
- $d_8d_9d_{10}=289$ делится на $17$

Найдите сумму всех **панцифровых** чисел от $0$ до $9$ с этим свойством.

# Задача о рюкзаке

У вас есть рюкзак ограниченной вместимости и список предметов с весами и стоимостями. Найдите максимальную стоимость предметов, которые можно уложить в рюкзак.

**Формат ввода**
Первая строка содержит два числа: `n` (количество предметов) и `capacity` (вместимость).
Следующие `n` строк содержат по два числа: вес и стоимость предмета.

**Формат вывода**
Выведите одно число — максимальную стоимость.

```task
In:
3 5
2 10
3 15
5 30

Out:
30

In:
6 10
2 10
3 15
5 30
7 20
1 5
4 10

Out:
50
```

# **Устойчивость числа**

Напишите функцию `persistence`, которая для положительного целого числа `num` возвращает его мультипликативную персистентность — количество шагов, за которые число преобразуется в однозначное в результате перемножения его цифр.


```text
39  -> 3  # 3*9=27 -> 2*7=14 -> 1*4=4
999 -> 4  # 9*9*9=729 -> 7*2*9=126 -> 1*2*6=12 -> 1*2=2  
4   -> 0 
```

## Билет 23
# Двухсвязный список

Вам необходимо реализовать класс для представления узла двухсвязного списка и сам двухсвязный список. Двухсвязный список — это структура данных, в которой каждый узел содержит данные и ссылки на следующий и предыдущий узлы.

- **Класс `Node`**:

    - Реализуйте класс `Node`, который будет представлять узел двухсвязного списка. Узел должен содержать:
        - `data`: данные узла (может быть любого типа).
        - `next`: ссылка на следующий узел (по умолчанию `None`).
        - `prev`: ссылка на предыдущий узел (по умолчанию `None`).

- **Класс `DoublyLinkedList`**:
    
    - Реализуйте класс `DoublyLinkedList`, который будет предоставлять методы для работы с двухсвязным списком:
        - `append(data)`: добавляет новый узел в конец списка.
        - `prepend(data)`: добавляет новый узел в начало списка.
        - `delete(data)`: удаляет первый узел, содержащий заданные данные.
        - `display()`: выводит элементы списка от начала до конца.
        - `display_reverse()`: выводит элементы списка от конца до начала.

# Делимость подстроки

Число $1406357289$ является **панцифровым** числом от $0$ до $9$, поскольку оно состоит из каждой цифры от $0$ до $9$ в определенном порядке, но оно также обладает довольно интересным свойством делимости на подстроки.

Пусть $d_1$ — $1^{st}$ цифра, $d_2$ — $2^{nd}$ цифра и т.д. Таким образом, отметим следующее:

- $d_2d_3d_4=406$ делится на $2$
- $d_3d_4d_5=063$ делится на $3$
- $d_4d_5d_6=635$ делится на $5$
- $d_5d_6d_7=357$ делится на $7$
- $d_6d_7d_8=572$ делится на $11$
- $d_7d_8d_9=728$ делится на $13$
- $d_8d_9d_{10}=289$ делится на $17$

Найдите сумму всех **панцифровых** чисел от $0$ до $9$ с этим свойством.

# Soundex

Известный алгоритм Soundex определяет, похожи ли два английских слова по звучанию. На вход он принимает слово и заменяет его на некоторый четырёхсимвольный код. Если коды двух слов совпадают, то слова, как правило, звучат похоже.

Вам требуется реализовать этот алгоритм. Он работает так:

1. Первая буква слова сохраняется.
2. В остальной части слова буквы a, e, h, i, o, u, w и y удаляются;
3. Оставшиеся буквы заменяются на цифры от 1 до 6, причём похожим по звучанию буквам соответствуют одинаковые цифры:
   - b, f, p, v: 1
   - c, g, j, k, q, s, x, z: 2
   - d, t: 3
   - l: 4
   - m, n: 5
   - r: 6
4. Любая последовательность идущих подряд одинаковых цифр сокращается до одной такой цифры.
5. Итоговая строка обрезается до первых четырёх символов.
6. Если длина строки получилась меньше четырёх символов, в конце добавляются нули.

**Примеры:**
- ammonium → ammnm → a5555 → a5 → a500
- implementation → implmnttn → i51455335 → i514535 → i514

# **Сумма цифр и цифровой корень**

Цифровой корень — это рекурсивная сумма всех цифр числа.

Для заданного целого неотрицательного числа `n` необходимо вычислить сумму его цифр. Если полученное значение содержит более одной цифры, процедура повторяется до тех пор, пока не будет получено однозначное число. 


```text
16      -> 1 + 6 = 7  
942     -> 9 + 4 + 2 = 15 -> 1 + 5 = 6  
132189  -> 1 + 3 + 2 + 1 + 8 + 9 = 24 -> 2 + 4 = 6  
493193  -> 4 + 9 + 3 + 1 + 9 + 3 = 29 -> 2 + 9 = 11 -> 1 + 1 = 2
```

## Билет 24
# Бинарное дерево

Вам необходимо реализовать класс для представления узла бинарного дерева и само бинарное дерево. Бинарное дерево — это структура данных, в которой каждый узел может иметь не более двух дочерних узлов, обычно называемых левым и правым.

1. **Класс `TreeNode`**:
    - Реализуйте класс `TreeNode`, который будет представлять узел бинарного дерева. Узел должен содержать:
        - `data`: данные узла (может быть любого типа).
        - `left`: ссылка на левое дочернее узло (по умолчанию `None`).
        - `right`: ссылка на правое дочернее узло (по умолчанию `None`).

2. **Класс `BinaryTree`**:
    
    - Реализуйте класс `BinaryTree`, который будет предоставлять методы для работы с бинарным деревом:
        - `insert(data)`: добавляет новый узел в дерево. Элементы меньшие корня - в левое поддерево, большие - в правоедобавляет новый узел в дерево. Элементы меньшие либо равные корню - в левое поддерево, большие - в правое.
        - `search(data)`: ищет узел с заданными данными и возвращает его, если он найден, или `None`, если не найден.
        - `in_order_traversal()`: выполняет обход дерева в симметричном порядке (левое, корень, правое).
        - `pre_order_traversal()`: выполняет обход дерева в префиксном порядке (корень, левое, правое).
        - `post_order_traversal()`: выполняет обход дерева в постфиксном порядке (левое, правое, корень).

# Сумма регулярных чисел

Вам дан обычный массив `arr`. Назовем "шагом" разность между двумя соседними элементами.

Ваша задача — просуммировать элементы, принадлежащие последовательностям из как минимум 3 последовательных элементов, в которых шаг между элементами постоянен. Последовательности должны быть максимально возможной длины.

Обратите внимание: некоторые элементы могут принадлежать двум последовательностям и должны учитываться дважды.

Пример:
Для `arr = [54, 70, 86, 1, -2, -5, 0, 5, 78, 145, 212, 15]` ответ равен 639.

В массиве 4 последовательности с постоянным шагом:

`{54, 70, 86}` с шагом `+16`

`{1, -2, -5}` с шагом `-3`

`{-5, 0, 5}` с шагом `+5`

`{78, 145, 212}` с шагом `+67`

Сумма: `(54+70+86) + (1-2-5) + (-5+0+5) + (78+145+212) = 639`

#  Пароли

Пароль от некоторого сервиса должен удовлетворять таким ограничениям:
- состоять из символов таблицы ASCII с кодами от 33 до 126;
- быть не короче 8 символов и не длиннее 14;
- из 4 классов символов — большие буквы, маленькие буквы, цифры, прочие символы — в пароле должны присутствовать не менее трёх любых.

Напишите программу, которая проверит, что введённый пароль подходит под эти ограничения.

**Пример:**
```
In: "Password123!"
Out: True

In: "abc123"
Out: False
```

# **Проверка маршрута прогулки**

Город Картезия имеет идеальную сетку улиц. Вы всегда проходите 1 блок за 1 минуту. Функция должна вернуть `true`, если предложенный маршрут:
- Занимает ровно 10 минут.
- Возвращает вас в начальную точку.

**Примечание:** Маршрут состоит из символов `'n'`, `'s'`, `'e'`, `'w'`. Массив не пуст.

**Примеры тестов:**
```text
is_valid_walk(['n','s','n','s','n','s','n','s','n','s']) -> True  
is_valid_walk(['w','e','w','e','w','e','w','e','w','e','w','e']) -> False  
is_valid_walk(['w']) -> False  
is_valid_walk(['n','n','n','s','n','s','n','s','n','s']) -> False
```

## Билет 25
# Очередь

Вам необходимо реализовать класс `Queue`, который будет представлять собой очередь. Очередь — это структура данных, работающая по принципу "первый пришёл — первый вышел" (FIFO).

**Класс `Queue`**:
- Реализуйте класс `Queue`, который будет содержать следующие методы:
    - `__init__(self)`: инициализирует пустую очередь.
    - `is_empty(self)`: возвращает `True`, если очередь пуста, и `False` в противном случае.
    - `enqueue(self, item)`: добавляет элемент в конец очереди.
    - `dequeue(self)`: удаляет и возвращает элемент из начала очереди. Если очередь пуста, необходимо вызвать исключение `IndexError` (или `Exception`).
    - `front(self)`: возвращает элемент из начала очереди без удаления. Если очередь пуста, необходимо вызвать исключение `IndexError` (или `Exception`).
    - `size(self)`: возвращает количество элементов в очереди.

# Сумма регулярных чисел

Вам дан обычный массив `arr`. Назовем "шагом" разность между двумя соседними элементами.

Ваша задача — просуммировать элементы, принадлежащие последовательностям из как минимум 3 последовательных элементов, в которых шаг между элементами постоянен. Последовательности должны быть максимально возможной длины.

Обратите внимание: некоторые элементы могут принадлежать двум последовательностям и должны учитываться дважды.

Пример:
Для `arr = [54, 70, 86, 1, -2, -5, 0, 5, 78, 145, 212, 15]` ответ равен 639.

В массиве 4 последовательности с постоянным шагом:

`{54, 70, 86}` с шагом `+16`

`{1, -2, -5}` с шагом `-3`

`{-5, 0, 5}` с шагом `+5`

`{78, 145, 212}` с шагом `+67`

Сумма: `(54+70+86) + (1-2-5) + (-5+0+5) + (78+145+212) = 639`

# Похожие названия 

Пара слов интересная, если слова отличаются ровно в одной букве.

Дан набор слов одинаковой длины. Вычислите количество интересных пар.

**Формат ввода**  
Первая строка содержит одно число n — количество слов.  
Далее следуют n строк, каждая содержит ровно одну непустую строку, состоящую из не более чем 10 символов английского алфавита. Символы могут быть верхнего и нижнего регистра.

**Формат вывода**  
Вывод должен содержать одно число — количество интересных пар слов.

**Пример:**
```
In:
3
abc
abd
bbc

Out:
2
```

# **Сумма цифр и цифровой корень**

Цифровой корень — это рекурсивная сумма всех цифр числа.

Для заданного целого неотрицательного числа `n` необходимо вычислить сумму его цифр. Если полученное значение содержит более одной цифры, процедура повторяется до тех пор, пока не будет получено однозначное число. 


```text
16      -> 1 + 6 = 7  
942     -> 9 + 4 + 2 = 15 -> 1 + 5 = 6  
132189  -> 1 + 3 + 2 + 1 + 8 + 9 = 24 -> 2 + 4 = 6  
493193  -> 4 + 9 + 3 + 1 + 9 + 3 = 29 -> 2 + 9 = 11 -> 1 + 1 = 2
```

## Билет 26
# Связный список 

Вам необходимо реализовать класс `LinkedList`, который будет представлять собой связный список. Связный список — это структура данных, состоящая из узлов, каждый из которых содержит данные и ссылку на следующий узел в списке.

- **Класс `Node`**:
    
    - Реализуйте класс `Node`, который будет представлять отдельный узел в списке. Узел должен содержать:
        - `data`: данные, хранящиеся в узле.
        - `next`: ссылка на следующий узел (по умолчанию `None`).
- **Класс `LinkedList`**:
    
    - Реализуйте класс `LinkedList`, который будет содержать следующие методы:
        - `__init__(self)`: инициализирует пустой связный список.
        - `is_empty(self)`: возвращает `True`, если список пуст, и `False` в противном случае.
        - `append(self, data)`: добавляет новый узел с указанными данными в конец списка.
        - `prepend(self, data)`: добавляет новый узел с указанными данными в начало списка.
        - `delete(self, data)`: удаляет узел с указанными данными из спискаудаляет первый найденный узел с указанными данными из списка. Если узел с такими данными не найден, метод не делает ничего (или выводит сообщение).
        - `display(self)`: выводит данные всех узлов в списке.

# Делимость подстроки

Число $1406357289$ является **панцифровым** числом от $0$ до $9$, поскольку оно состоит из каждой цифры от $0$ до $9$ в определенном порядке, но оно также обладает довольно интересным свойством делимости на подстроки.

Пусть $d_1$ — $1^{st}$ цифра, $d_2$ — $2^{nd}$ цифра и т.д. Таким образом, отметим следующее:

- $d_2d_3d_4=406$ делится на $2$
- $d_3d_4d_5=063$ делится на $3$
- $d_4d_5d_6=635$ делится на $5$
- $d_5d_6d_7=357$ делится на $7$
- $d_6d_7d_8=572$ делится на $11$
- $d_7d_8d_9=728$ делится на $13$
- $d_8d_9d_{10}=289$ делится на $17$

Найдите сумму всех **панцифровых** чисел от $0$ до $9$ с этим свойством.

# Расширенная форма числа

Преобразуйте число в расширенную форму (например, 70304 → "70000 + 300 + 4").

**Формат ввода**
На вход подается одно целое положительное число.

**Формат вывода**
Выведите строку в расширенной форме.

```python
In: 12
Out: "10 + 2"

In: 70304
Out: "70000 + 300 + 4"
```

# **Проверка маршрута прогулки**

Город Картезия имеет идеальную сетку улиц. Вы всегда проходите 1 блок за 1 минуту. Функция должна вернуть `true`, если предложенный маршрут:
- Занимает ровно 10 минут.
- Возвращает вас в начальную точку.

**Примечание:** Маршрут состоит из символов `'n'`, `'s'`, `'e'`, `'w'`. Массив не пуст.

**Примеры тестов:**
```text
is_valid_walk(['n','s','n','s','n','s','n','s','n','s']) -> True  
is_valid_walk(['w','e','w','e','w','e','w','e','w','e','w','e']) -> False  
is_valid_walk(['w']) -> False  
is_valid_walk(['n','n','n','s','n','s','n','s','n','s']) -> False
```

## Билет 27
# Двухсвязный список

Вам необходимо реализовать класс для представления узла двухсвязного списка и сам двухсвязный список. Двухсвязный список — это структура данных, в которой каждый узел содержит данные и ссылки на следующий и предыдущий узлы.

- **Класс `Node`**:

    - Реализуйте класс `Node`, который будет представлять узел двухсвязного списка. Узел должен содержать:
        - `data`: данные узла (может быть любого типа).
        - `next`: ссылка на следующий узел (по умолчанию `None`).
        - `prev`: ссылка на предыдущий узел (по умолчанию `None`).

- **Класс `DoublyLinkedList`**:
    
    - Реализуйте класс `DoublyLinkedList`, который будет предоставлять методы для работы с двухсвязным списком:
        - `append(data)`: добавляет новый узел в конец списка.
        - `prepend(data)`: добавляет новый узел в начало списка.
        - `delete(data)`: удаляет первый узел, содержащий заданные данные.
        - `display()`: выводит элементы списка от начала до конца.
        - `display_reverse()`: выводит элементы списка от конца до начала.

# Сумма регулярных чисел

Вам дан обычный массив `arr`. Назовем "шагом" разность между двумя соседними элементами.

Ваша задача — просуммировать элементы, принадлежащие последовательностям из как минимум 3 последовательных элементов, в которых шаг между элементами постоянен. Последовательности должны быть максимально возможной длины.

Обратите внимание: некоторые элементы могут принадлежать двум последовательностям и должны учитываться дважды.

Пример:
Для `arr = [54, 70, 86, 1, -2, -5, 0, 5, 78, 145, 212, 15]` ответ равен 639.

В массиве 4 последовательности с постоянным шагом:

`{54, 70, 86}` с шагом `+16`

`{1, -2, -5}` с шагом `-3`

`{-5, 0, 5}` с шагом `+5`

`{78, 145, 212}` с шагом `+67`

Сумма: `(54+70+86) + (1-2-5) + (-5+0+5) + (78+145+212) = 639`

# Soundex

Известный алгоритм Soundex определяет, похожи ли два английских слова по звучанию. На вход он принимает слово и заменяет его на некоторый четырёхсимвольный код. Если коды двух слов совпадают, то слова, как правило, звучат похоже.

Вам требуется реализовать этот алгоритм. Он работает так:

1. Первая буква слова сохраняется.
2. В остальной части слова буквы a, e, h, i, o, u, w и y удаляются;
3. Оставшиеся буквы заменяются на цифры от 1 до 6, причём похожим по звучанию буквам соответствуют одинаковые цифры:
   - b, f, p, v: 1
   - c, g, j, k, q, s, x, z: 2
   - d, t: 3
   - l: 4
   - m, n: 5
   - r: 6
4. Любая последовательность идущих подряд одинаковых цифр сокращается до одной такой цифры.
5. Итоговая строка обрезается до первых четырёх символов.
6. Если длина строки получилась меньше четырёх символов, в конце добавляются нули.

**Примеры:**
- ammonium → ammnm → a5555 → a5 → a500
- implementation → implmnttn → i51455335 → i514535 → i514

# **Кодирование дубликатов**

Необходимо преобразовать строку в новую строку, где каждый символ заменяется на `"("`, если он встречается в исходной строке только один раз, и на `")"`, если он встречается более одного раза. Регистр символов при определении дубликатов игнорируется.


```text
"din"      -> "((("  
"recede"   -> "()()()"  
"Success"  -> ")())())"  
"(( @"     -> "))(("
```

**Примечание:** В описаниях задач может упоминаться `"XXX"` как ожидаемый результат, а не входные данные.

## Билет 28
# Приоритетная Очередь

Вам необходимо реализовать приоритетную очередь с использованием собственного алгоритма. Эта очередь будет хранить элементы с приоритетами и обеспечивать доступ к элементам с наивысшим приоритетом.

**Класс `PriorityQueue`**:

- Реализуйте класс `PriorityQueue`, который будет содержать следующие методы:
    - `__init__(self)`: инициализирует пустую приоритетную очередь.
    - `push(self, item, priority)`: добавляет элемент с заданным приоритетом в очередь.
    - `pop(self)`: удаляет и возвращает элемент с наивысшим приоритетом удаляет и возвращает элемент с наивысшим приоритетом. Наивысший приоритет соответствует наибольшему числовому значению `priority`.
    - `peek(self)`: возвращает элемент с наивысшим приоритетом, не удаляя его.
    - `is_empty(self)`: возвращает `True`, если очередь пуста, иначе — `False`.
    - `size(self)`: возвращает количество элементов в очереди.

# Причудливые квадраты

У числа 3025 есть замечательная особенность: если разделить его десятичное представление на две строки равных длин (30 и 25) и возведите в квадрат сумму полученных таким образом чисел, вы получите исходное число: $(30 + 25)^2 = 3025$

Задача состоит в том, чтобы определить все числа с этим свойством, имеющие заданное четное количество цифр. Например, четырехзначные числа имеют диапазон от 0000 до 9999. Обратите внимание, что ведущие нули следует брать в учетную запись.  Это означает, что $0001$ равно $(00 + 01)^2$  и это причудливое число из 4 цифр. Количество цифр может быть 2,4,6 или 8. Однако стоит задуматься об эффективности 

$$N = a_1 a_2 \ldots a_k a_{k+1} a_{k+2} \ldots a_{2k} $$
$$L = a_1 a_2 \ldots a_k $$
$$R = a_{k+1} a_{k+2} \ldots a_{2k} $$
$$(L + R)^2 = N$$

- $N$ — число с $2k$ цифрами.
- $L$ — левая часть из первых $k$ цифр.
- $R$ — правая часть из последних $k$ цифр.
- Условие, при котором число $N$ считается "причудливым".

Входные данные 
```text
2
```

Выходные данные
```text
00 
01 
81 
```

# Похожие названия 

Пара слов интересная, если слова отличаются ровно в одной букве.

Дан набор слов одинаковой длины. Вычислите количество интересных пар.

**Формат ввода**  
Первая строка содержит одно число n — количество слов.  
Далее следуют n строк, каждая содержит ровно одну непустую строку, состоящую из не более чем 10 символов английского алфавита. Символы могут быть верхнего и нижнего регистра.

**Формат вывода**  
Вывод должен содержать одно число — количество интересных пар слов.

**Пример:**
```
In:
3
abc
abd
bbc

Out:
2
```

# **Реверс слов длиной более 5 символов**

Напишите функцию, которая принимает строку из одного или нескольких слов и возвращает её, развернув все слова **длиной пять и более символов**. Строка состоит только из букв и пробелов. Пробелы присутствуют только при наличии нескольких слов.


```text
"Hey fellow warriors"  -> "Hey wollef sroirraw"  
"This is a test"        -> "This is a test"  
"This is another test"  -> "This is rehtona test"
```

## Билет 29
# Очередь

Вам необходимо реализовать класс `Queue`, который будет представлять собой очередь. Очередь — это структура данных, работающая по принципу "первый пришёл — первый вышел" (FIFO).

**Класс `Queue`**:
- Реализуйте класс `Queue`, который будет содержать следующие методы:
    - `__init__(self)`: инициализирует пустую очередь.
    - `is_empty(self)`: возвращает `True`, если очередь пуста, и `False` в противном случае.
    - `enqueue(self, item)`: добавляет элемент в конец очереди.
    - `dequeue(self)`: удаляет и возвращает элемент из начала очереди. Если очередь пуста, необходимо вызвать исключение `IndexError` (или `Exception`).
    - `front(self)`: возвращает элемент из начала очереди без удаления. Если очередь пуста, необходимо вызвать исключение `IndexError` (или `Exception`).
    - `size(self)`: возвращает количество элементов в очереди.

# Не такая уж случайность

Вы — маг. Вы собираетесь выполнить фокус.

В вашей волшебной шляпе находится `b` черных и w белых шаров, а также у вас есть **неограниченный запас шаров обоих цветов**.

Вы просите аудиторию повторно удалять из шляпы по **два шара**, и после каждой удаленной пары вы добавляете один шар по следующему правилу:

1. **Если удаленные шары одного цвета, вы добавляете белый шар**.

2. **Если удаленные шары разного цвета, вы добавляете черный шар**.

Фокус заключается в предсказании цвета последнего оставшегося шара.
```python
    notSoRandom(1,1)->"Black"
    notSoRandom(2,1)->"White"
    notSoRandom(1,2)->"Black"
    notSoRandom(2,2)->"White"
    notSoRandom(6,9)->"White"
```

# Похожие названия 

Пара слов интересная, если слова отличаются ровно в одной букве.

Дан набор слов одинаковой длины. Вычислите количество интересных пар.

**Формат ввода**  
Первая строка содержит одно число n — количество слов.  
Далее следуют n строк, каждая содержит ровно одну непустую строку, состоящую из не более чем 10 символов английского алфавита. Символы могут быть верхнего и нижнего регистра.

**Формат вывода**  
Вывод должен содержать одно число — количество интересных пар слов.

**Пример:**
```
In:
3
abc
abd
bbc

Out:
2
```

# **Уникальные элементы с сохранением порядка**

Реализуйте функцию `unique_in_order`, которая принимает последовательность и возвращает список элементов, удалив повторяющиеся подряд элементы, сохранив исходный порядок.


```text
"AAAABBBCCDAABBB" -> ['A','B','C','D','A','B']  
"ABBCcAD" -> ['A','B','C','c','A','D']  
[1,2,2,3,3] -> [1,2,3]
```

## Билет 30
# Очередь

Вам необходимо реализовать класс `Queue`, который будет представлять собой очередь. Очередь — это структура данных, работающая по принципу "первый пришёл — первый вышел" (FIFO).

**Класс `Queue`**:
- Реализуйте класс `Queue`, который будет содержать следующие методы:
    - `__init__(self)`: инициализирует пустую очередь.
    - `is_empty(self)`: возвращает `True`, если очередь пуста, и `False` в противном случае.
    - `enqueue(self, item)`: добавляет элемент в конец очереди.
    - `dequeue(self)`: удаляет и возвращает элемент из начала очереди. Если очередь пуста, необходимо вызвать исключение `IndexError` (или `Exception`).
    - `front(self)`: возвращает элемент из начала очереди без удаления. Если очередь пуста, необходимо вызвать исключение `IndexError` (или `Exception`).
    - `size(self)`: возвращает количество элементов в очереди.

# Пути в сетке

У вас есть сетка с m строками и n столбцами. Верните количество уникальных путей из верхнего левого угла в нижний правый угол. Разрешенные движения: только вправо и вниз.

Например, в сетке ниже с 3 строками и 4 столбцами существует 10 уникальных путий:

```text
o--o--o--o
|  |  |  |
o--o--o--o
|  |  |  |
o--o--o--o
```

Примечание: в тестах встречаются сетки размером до 1000×1000, поэтому наивное решение не подойдет

# Обмены между массивами

Даны два массива `a` и `b`. За не более k обменов элементов между массивами, максимизируйте сумму массива `a`.

**Формат ввода**
Первая строка содержит три числа: `n`, `m` и `k` (длины массивов и максимальное количество обменов).
Вторая строка содержит `n` чисел — массив `a`.
Третья строка содержит `m` чисел — массив `b`.

**Формат вывода**
Выведите одно число — максимальную сумму массива `a` после обменов.

```python
In:
2 2 1
1 2
3 4

Out:
6
```

# **Реверс слов длиной более 5 символов**

Напишите функцию, которая принимает строку из одного или нескольких слов и возвращает её, развернув все слова **длиной пять и более символов**. Строка состоит только из букв и пробелов. Пробелы присутствуют только при наличии нескольких слов.


```text
"Hey fellow warriors"  -> "Hey wollef sroirraw"  
"This is a test"        -> "This is a test"  
"This is another test"  -> "This is rehtona test"
```

