# Тест 1 

**Дата проведения тестирования**: 1 октября 2025 года.

**Продолжительность мероприятия**: с 9:00 до 10:15, что составляет 1 час 15 минут.

Структура билета:

1. Включает три случайно отобранных вопроса из категории **Легкие**.
2. Один вопрос из категории **Сложные**.

Максимальное количество баллов за выполнение теста: 3 балла, начисляемых за корректное решение всех вопросов.

Особые условия: При успешном решении вопроса из категории **Сложные** студент получает премиальный бонус. Возможные варианты бонуса:

- Возможность повторного выбора билета на следующем тестировании.
- Исключение одной задачи из следующего билета, при условии, что исключаемая задача не является сложной.


---


# Легкие задач 

## **Задача о движении двух тел**

Даны два объекта, начинающие движение из разных точек на прямой. Первый объект (A) начинает движение из точки, расположенной на расстоянии `g` от начала координат, со скоростью `v1` . Второй объект (B) начинает движение из начала координат со скоростью `v2` и направляется в сторону объекта A.

 Определить момент времени `t` (в часах), в который объект B догонит объект A.

## **Преобразование строки к формату заглавных букв**

 Реализовать преобразование входной строки символов, при котором первый символ каждого слова преобразуется к верхнему регистру, а остальные символы — к нижнему.

 Строка символов, соответствующая входной строке, в которой каждое слово начинается с заглавной буквы.

*Пример:* Входная строка `"How can mirrors be real if our eyes aren't real"` должна быть преобразована в `"How Can Mirrors Be Real If Our Eyes Aren't Real"`.


## **Квадратичная конкатенация цифр числа**

 Для заданного целого неотрицательного числа требуется сформировать новое целое число путем выполнения следующей процедуры:
1. Каждая цифра в десятичном представлении исходного числа возводится в квадрат.
2. Полученные на предыдущем шаге числа (возможно, многозначные) объединяются (конкатенируются) в одно число в порядке следования соответствующих цифр в исходном числе.

*Пример:* Для входного числа `9119` процедура выполняется следующим образом: цифры `9`, `1`, `1`, `9` преобразуются в `81`, `1`, `1`, `81` соответственно. Результатом конкатенации является число `811181`.

## **Вычисление тетрации**

Тетрация (гипероператор 4-го порядка) для неотрицательного целого `n` и действительного `x` определяется рекурсивно:
$$
{^{0}x} = 1, \quad {^{n}x} = x^{\left( {^{(n-1)}x} \right)} \quad \text{для} \quad n > 0.
$$
Степенные башни вычисляются сверху вниз (правоассоциативно).

$$^{5}2 = 2^{2^{2^{2^{2}}}} = 2^{(2^{4})}=2^{16}=65536$$

1. Реализовать функцию для вычисления значения $^{n}x$}`.
2. Для малых положительных действительных `x` и неотрицательных целых `n`


## **Численное вычисление числа $\pi$ по формуле Уоллиса**

Число $\pi$ может быть представлено в виде бесконечного произведения (формула Уоллиса):
$$
\pi = 2 \prod_{i=1}^{\infty} \frac{4i^2}{4i^2 - 1}.
$$
 Реализовать алгоритм приближенного вычисления значения $\pi$ путем вычисления частичного произведения до заданного числа итераций `N`.


## **Вычисление расстояния Хэмминга**

 Расстояние Хэмминга между двумя строками одинаковой длины — это количество позиций, в которых соответствующие **символы строк различаются**.

 Разработать алгоритм, который для двух заданных строк `s1` и `s2` одинаковой длины вычисляет расстояние Хэмминга между ними.


## **Двойной факториал для нечетных чисел**

Двойной факториал для нечетного натурального числа `n` определяется как произведение всех нечетных натуральных чисел, не превосходящих `n`:
$$
n!! = \prod_{k=1}^{\frac{n+1}{2}} (2k - 1) = 1 \cdot 3 \cdot 5 \cdot \ldots \cdot n.
$$
 Реализовать функцию вычисления двойного факториала для нечетных неотрицательных целых чисел.


## **Двойной факториал для четных чисел**

Двойной факториал для четного натурального числа `n` определяется как произведение всех четных натуральных чисел, не превосходящих `n`:
$$
n!! = \prod_{k=1}^{\frac{n}{2}} (2k) = 2 \cdot 4 \cdot 6 \cdot \ldots \cdot n.
$$
 Реализовать функцию вычисления двойного факториала для четных неотрицательных целых чисел.


## **Вес Хэмминга НОД**


*   Наибольший общий делитель (НОД) двух целых чисел `a` и `b` — это наибольшее положительное целое число, которое делит как `a`, так и `b` без остатка. НОД(0, 0) полагается равным 0.
*   Вес Хэмминга (количество единиц) двоичного представления целого неотрицательного числа — это количество символов `1` в его записи по основанию 2.

 Разработать функцию, которая для двух целых чисел `x` и `y` возвращает вес Хэмминга бинарного представления их НОД. Функция должна корректно обрабатывать случай, когда оба аргумента равны нулю, а также отрицательные входные данные.

*Пример:* НОД(300, 45) = 15. Бинарное представление числа 15 — `1111`, следовательно, вес Хэмминга равен 4.

## **Поиск сбалансированного подсписка**

 Для заданного списка чисел `lst` требуется найти такой его **подсписок** (последовательный отрезок исходного списка), который удовлетворяет следующему условию: сумма первого и последнего элемента этого подсписка равна сумме всех остальных его элементов.


1. Изначально в качестве кандидата рассматривается весь список `lst`.
2. Если сумма первого и последнего элемента кандидата равна сумме остальных его элементов, кандидат является решением.
3. Если условие не выполняется и длина кандидата больше или равна 3, он усекается путем удаления первого и последнего элемента, и процедура проверки повторяется для нового подсписка.
4. Процесс продолжается до выполнения условия или до тех пор, пока подсписок не станет пустым. Если условие не выполняется ни для одного подсписка, возвращается пустой список.

*Пример:* Для списка `[1, 2, 3, 4, 5]`:
*   Проверка `[1, 2, 3, 4, 5]`: $1 + 5 = 6; \space 2 + 3 + 4 = 9; \space 6 \ne 9.$
*   Проверка `[2, 3, 4]`: $2 + 4 = 6; \space 3 = 3; \space 6 \ne 3.$
*   Проверка `[3]`: $3 + 3 = 6$; сумма остальных (пустого множества) $= 0$; $6 \ne 0$.
*   Результат: `[]`.
## **Проверка на степень двойки**

 Неотрицательное целое число `n` является степенью двойки, если существует такое неотрицательное целое число `k`, что $n = 2^k$.

 Реализовать функцию (или метод), которая для заданного неотрицательного целого числа `n` возвращает `True`, если `n` является степенью двойки, и `False` в противном случае. Гарантируется, что входное число всегда неотрицательно.

*Примеры:*
```
power_of_two(1024) -> True
power_of_two(4096) -> True
power_of_two(333)  -> False
```
## **Приведение имён к нормализованному виду**

Создайте функцию, которая принимает массив имён и возвращает массив, в котором каждое имя записано с заглавной первой буквы, а остальные буквы приведены к нижнему регистру.

```rust
["jo", "nelson", "jurie"]     -> ["Jo", "Nelson", "Jurie"]
["KARLY", "DANIEL", "KELSEY"] -> ["Karly", "Daniel", "Kelsey"]
```

## **Счётчик общих битов**

Завершите реализацию метода, который возвращает `true`, если два целых числа имеют **не менее двух** общих единичных битов, и `false` в противном случае. Для упрощения можно считать, что все числа неотрицательные.


```
 7  =  0111 # в двоичной системе
10  =  1010
15  =  1111
```
*   Числа `7` и `10` имеют только один общий единичный бит (на позиции 2) -> `false`.
*   Числа `7` и `15` имеют три общих единичных бита (на позициях 1, 2 и 3) -> `true`.
*   Числа `10` и `15` имеют два общих единичных бита (на позициях 0 и 2) -> `true`.

## **Сокращение дроби**

Напишите функцию, которая сокращает дроби до их несократимого вида. Дробь представляется в виде массива/кортежа (в зависимости от языка программирования) из двух строго положительных целых чисел `[числитель, знаменатель]`. Функция должна вернуть сокращённую дробь в том же формате.


$$\frac{45}{120} = \frac {3}{8} $$

```
Вход:  [45, 120] # 45/120 
Выход: [3, 8]    # 3/8
```

Все числители и знаменатели являются **положительными** целыми числами.

## **Сумма первых n членов ряда**

Напишите функцию, которая возвращает n-ю частичную сумму следующего ряда (n — входной параметр), то есть сумму первых n членов последовательности.

**Ряд:** 1 + 1/4 + 1/7 + 1/10 + 1/13 + 1/16 + …


*   Определите закономерность формирования ряда для решения задачи.
*   Ответ должен быть округлён до двух знаков после запятой и возвращён в виде строки.
*   Если задано значение `0`, функция должна вернуть `"0.00"`.
*   В качестве аргументов будут передаваться только натуральные числа.


```
n = 1 --> 1         --> "1.00"
n = 2 --> 1 + 1/4   --> "1.25"
n = 5 --> 1 + 1/4 + 1/7 + 1/10 + 1/13 --> "1.57"
```

## **Красный Рыцарь**

Красный Рыцарь преследует две пешки. Какую пешку он поймает и где?

Два целых числа:
*   `N` — вертикальная позиция Красного Рыцаря (`0` или `1`).
*   `P` — горизонтальная позиция обеих пешек (целое число от `2` до `1000000`).


Структура данных (кортеж, массив, объект и т.д.), содержащая:
1.  `"Black"` или `"White"` — название пешки, которая была поймана.
2.  Горизонтальную позицию, на которой пешка была поймана.

**Условия:**
*   Красный Рыцарь всегда начинает с горизонтальной позиции `0`.
*   Чёрная пешка всегда находится внизу (вертикальная позиция `1`).
*   Белая пешка всегда находится вверху (вертикальная позиция `0`).
*   Пешки ходят первыми и одновременно.
*   Красный Рыцарь за ход перемещается на 2 клетки вперёд и на 1 клетку вверх или вниз.
*   Пешки за ход перемещаются на 1 клетку вперёд.
*   Обе пешки начинают с одной и той же горизонтальной позиции.


```
0 K --| _ B-> _ _ _ ...
1 _ _ v _ W-> _ _ _ ...
  0 1 2 3 4 5 6 7 8 ...
```

> **K - Красный Рыцарь, B - Черная Пешка, W - Белая Пешка, `_` - пустое поле,**

```
[0, 4] -> ('White', 8)
[0, 7] -> ('Black', 14)
[1, 6] -> ('Black', 12)
[1, 5] -> ('White', 10)
```

## **Категоризация нового члена клуба**

Крокетный клуб "Western Suburbs" имеет две категории членства: Senior (Старшая) и Open (Открытая). Клубу требуется помощь в разработке формы заявки, которая будет определять категорию для потенциальных членов.

Чтобы стать членом старшей категории, человек должен быть не моложе 55 лет и иметь гандикап больше 7. В этом крокетном клубе гандикапы находятся в диапазоне от -2 до +26; чем лучше игрок, тем ниже его гандикап.

Список пар. Каждая пара содержит информацию об одном потенциальном члене: целое число (возраст) и целое число (гандикап).

Список строковых значений (`"Senior"` или `"Open"`), указывающих категорию для каждого потенциального члена.


```
[[18, 20], [45, 2], [61, 12], [37, 6], [21, 21], [78, 9]] -> ["Open", "Open", "Senior", "Open", "Open", "Senior"]
```

## **Логическое отрицание**

В программировании широко используется оператор логического отрицания (`!`), который инвертирует значение условия.

```javascript
!false = true
!!false = false
```

Ваша задача — завершить реализацию функции `negationValue()`, которая принимает строку из символов отрицания и значение, а затем возвращает результат последовательного применения этих отрицаний к значению.

```javascript
negationValue("!", false); //-> true
negationValue("!!!!!", true); //-> false
negationValue("!!", []); //-> true (непустой массив в логическом контексте истинен)
```

## **Генерация**

Генетические алгоритмы работают с популяциями хромосом. Для создания начальной популяции хромосом необходимо сгенерировать случайные бинарные строки заданной длины.

В этой задаче требуется реализовать функцию `generate`, которая принимает параметр `length` (длина) и возвращает случайную бинарную строку длиной `length` символов.

Генерация хромосомы длиной 4: `generate(4)` может вернуть `0010`, `1110`, `1111` или любую из $2^4$ возможностей.

## **Пентобоначчи**

Рассмотрим следующую последовательность:

$$
P(n) = 
\begin{cases} 
0 & \text{если } n = 0 \\ 
1 & \text{если } n = 1 \\ 
1 & \text{если } n = 2 \\ 
2 & \text{если } n = 3 \\ 
4 & \text{если } n = 4 \\ 
P(n-1) + P(n-2) + P(n-3) + P(n-4) + P(n-5) & \text{если } n \geq 5 
\end{cases}
$$

Эта формула описывает, как вычисляются члены последовательности Пентобоначчи в зависимости от значения \( n \).

Ваша задача — определить количество **различных нечётных значений** в последовательности от 0-го до n-го члена включительно. Число n (порядковый номер члена) передаётся как неотрицательное целое число.

Значение 1 является единственным повторяющимся нечётным числом в последовательности и должно быть учтено **только один раз.**

```
count_odd_pentaFib(5)  -> 1 # Последовательность до 5-го члена: 0, 1, 1, 2, 4, 8 (нечётное число только 1, учтённое один раз).
count_odd_pentaFib(10) -> 3 # Нечётные члены: [1, 1, 31, 61] (три различных значения: 1, 31, 61).
count_odd_pentaFib(15) -> 5 # Нечётные члены: [1, 1, 31, 61, 1793, 3525] (пять различных значений: 1, 31, 61, 1793, 3525).
```
## **Сортировка по количеству битов**

В этой задаче требуется отсортировать массив 32-битных целых чисел в порядке возрастания количества **единичных битов** в их двоичном представлении.

Для массива `[7, 6, 15, 8]`:
*   Число 7 имеет **3** единичных бита (000...0**111**)
*   Число 6 имеет **2** единичных бита (000...0**11**0)
*   Число 15 имеет **4** единичных бита (000...**1111**)
*   Число 8 имеет **1** единичный бит (000...**1**000)

Таким образом, отсортированный массив будет иметь вид: `[8, 6, 7, 15]`.

Если два числа имеют одинаковое количество единичных битов, они должны быть отсортированы по возрастанию их числовых значений.

Числа $10$ (`...1010`) и $12$ (`...1100`) имеют по **2 единичных бита**, но число 10 меньше 12, поэтому в отсортированном массиве оно должно стоять первым.

Напишите функцию, которая принимает массив целых чисел и сортирует его описанным выше способом.


```
[3, 8, 3, 6, 5, 7, 9, 1] -> [1, 8, 3, 3, 5, 6, 9, 7]
```
## **Сумма чисел в интервале**

 Для двух целых чисел `a` и `b` (которые могут быть положительными или отрицательными) требуется найти сумму всех целых чисел в замкнутом интервале между ними, включая граничные значения. Если числа равны, следует вернуть значение `a` (или `b`).

 Числа `a` и `b` не упорядочены.

*Примеры:*
```
(1, 0)  -> `1` # 1 + 0 = 1
(1, 2)  -> `3` # 1 + 2 = 3
(-1, 2) -> `2` # -1 + 0 + 1 + 2 = 2
```

## **Проверка треугольного числа**

 Треугольное число — это количество точек, которыми можно заполнить равносторонний треугольник. *n*-е треугольное число задается формулой:
$$ T(n) = \frac{n(n + 1)}{2} $$
где `n` — длина стороны треугольника (натуральное число).

 Для заданного целого числа `T` из интервала `[1..2147483646]` определить, является ли оно треугольным числом.

## **Минимальная сумма попарных произведений**

 Для заданного списка положительных целых чисел четного размера требуется найти минимальную возможную сумму, получаемую при попарном перемножении элементов списка, при условии что каждый элемент используется ровно один раз.

 Для минимизации суммы следует перемножать наибольшие элементы с наименьшими.

*Примеры:*
```
minSum([5,4,2,3])         -> 22  # 5*2 + 3*4 = 22
minSum([12,6,10,26,3,24]) -> 342 # 26*3 + 24*6 + 12*10 = 342
```

## **Произведение k максимальных чисел**

 Для заданного списка целых чисел (который может содержать положительные, отрицательные числа и нули) и целого числа `k` (где `k` меньше или равно длине списка) требуется найти максимальное возможное произведение среди всех подпоследовательностей длины `k`.

*Примеры:*
```
maxProduct([4,3,5], 2)            -> 20  # 5 * 4       = 20
maxProduct([-4,-27,-15,-6,-1], 2) -> 4   # -4 * -1     = 4
maxProduct([10,3,-1,-27], 3)      -> -30 # 10 * 3 * -1 = -30
```
## **Максимальный разрыв в отсортированной последовательности**

 Максимальный разрыв для списка чисел — это наибольшая разность между последовательными элементами после сортировки списка по возрастанию.

 Для заданного списка целых чисел (который может содержать положительные, отрицательные числа и нули) найти максимальный разрыв. Разность вычисляется как абсолютное значение разности между элементами.

*Примеры:*
```
maxGap([13,10,5,2,9])           -> 4 
maxGap([-3,-27,-4,-2])          -> 23 
maxGap([-54,37,0,64,640,0,-15]) -> 576
```
## **Сумма весов двух команд**

 Несколько человек с заданными весами (положительные целые числа) стоят в ряд. Они распределяются по двум командам поочередно: первый в команду 1, второй в команду 2, третий снова в команду 1, и т.д.

 Найти общий вес каждой команды. Возвращаемое значение — пара чисел `[вес_команды_1, вес_команды_2]`.

*Примеры:*
```
[13, 27, 49]     -> [62, 27]   # 13+49=62,  27=27
[50, 60, 70, 80] -> [120, 140] # 50+70=120, 60+80=140
```
## **Минимальное число для получения простой суммы**

 Для заданного списка положительных целых чисел найти минимальное неотрицательное целое число, которое нужно добавить к сумме элементов списка, чтобы получить простое число. Если текущая сумма уже является простым числом, следует вернуть 0.

Новое простое число должно быть ближайшим простым числом, большим или равным исходной сумме.

*Примеры:*
```
[3,1,2]      -> 1 # (сумма=6, ближайшее простое для 6 это 7, 7 - 6 = 1
[2,12,8,4,6] -> 5 # (сумма=32, ближайшее простое для 32 это 37, 37 - 32 = 5
```
## **Сбалансированные числа**

 Сбалансированное число — это число, у которого сумма цифр слева от средних цифр равна сумме цифр справа от них. Средние цифры в расчет не принимаются.

*   Для числа с нечетным количеством цифр средняя цифра одна.
*   Для числа с четным количеством цифр средних цифры две.

 Для заданного положительного целого числа определить, является ли оно сбалансированным. Вернуть строку `"Balanced"` или `"Not Balanced"`.

*Примеры:*
```
7      -> `"Balanced"     # суммы слева и справа = 0
295591 -> `"Not Balanced" # слева: 2+9=11, справа: 9+1=10 
59     -> `"Balanced"     # слева: 9, справа: 9
```
## **Сильные числа**

 Сильное число — это число, равное сумме факториалов своих цифр.

 Для заданного положительного целого числа определить, является ли оно сильным. Вернуть `"STRONG!!!!"` или `"Not Strong !!"`.

*Примеры:*
```
1   -> "STRONG!!!!"    # 1! = 1
145 -> "STRONG!!!!"    # 1! + 4! + 5! = 1+24+120=145
123 -> "Not Strong !!" # 1! + 2! + 3! = 9 != 123
```
## **Числа Дисариума**

 Число Дисариума — это число, которое равно сумме своих цифр, возведенных в степень, соответствующую их позиции (считая слева направо, начиная с 1).

 Для заданного положительного целого числа определить, является ли оно числом Дисариума. Вернуть `"Disarium !!"` или `"Not !!"`.

*Примеры:*
```
89  -> "Disarium !!" # 8^1 + 9^2 = 8+81=89
564 -> "Not !!"      # 5^1 + 6^2 + 4^3 = 5+36+64=105 != 564
```
## **Прыгающие числа**

 Прыгающее число — это число, в котором абсолютная разность между соседними цифрами равна **1**. Все однозначные числа считаются прыгающими.

 Для заданного положительного целого числа определить, является ли оно прыгающим. Вернуть `"Jumping!!"` или `"Not!!"`.

*Примеры:*
```
9  -> "Jumping!!"      # однозначное
23 -> "Jumping!!"      # |2-3|=1
79 -> "Not!!"          # |7-9|=2
4343456 -> "Jumping!!" # все соседние разности равны 1
```
## **Автоморфные числа**

 Автоморфное число — это число, квадрат которого оканчивается на это же число.

 Для заданного положительного целого числа определить, является ли оно автоморфным. Вернуть `"Automorphic"` или `"Not!!"`.

*Примеры:*
```
25 -> "Automorphic" # 25^{2}=625 оканчивается на 25
13 -> "Not!!"       # 13^{2}=169 не оканчивается на 13
76 -> "Automorphic" # 76^{2}=5776 оканчивается на 76
```
## **Сверхсовершенные числа**

 Сверхсовершенное число в диапазоне от $1$ до $N$ — это положительное целое число, двоичное представление которого начинается и заканчивается на $1$.

 Для заданного положительного целого числа $N$ найти все сверхсовершенные числа в диапазоне $[1, N]$. Вернуть отсортированный список.

*Примеры:*
```
extraPerfect(3) -> [1,3]
extraPerfect(7) -> [1,3,5,7] 
```
## **Аккуратные числа**

 Аккуратное число — это число, цифры которого расположены в неубывающем порядке (слева направо).

 Для заданного положительного целого числа определить, является ли оно аккуратным. Вернуть логическое значение.

*Примеры:*
```
12    -> true  # (1 <= 2)
32    -> false # (3 > 2)
13579 -> true  # (1 <= 3 <= 5 <= 7 <= 9)
2335  -> true  # (2 <= 3 = 3 <= 5)
```
## **Сумма без арифметических операторов**

Реализовать сложение двух целых чисел $a$ и $b$ без использования операторов $+$ и $-$ (и родственных им функций в некоторых языках).

Числа могут быть положительными, отрицательными или нулем.

*Примеры:*
```
add(5,19)    -> 24
add(-27,18)  -> -9
add(-14,-16) -> -30
```

## **Фильтрация нечисловых элементов из списка**

 Дан список, содержащий неотрицательные целые числа и строки. Требуется создать новый список, содержащий только числовые элементы, с фильтрацией всех строковых значений.

*Примеры:*
```
[1, 2, 'a', 'b']                -> [1, 2]
[1, 'a', 'b', 0, 15]            -> [1, 0, 15]
[1, 2, 'aasf', '1', '123', 123] -> [1, 2, 123]
```
## **Статистический анализ числовой последовательности**

 Для заданной последовательности целых чисел требуется вычислить два статистических показателя:
1. Количество положительных чисел в последовательности
2. Сумму всех отрицательных чисел в последовательности

Число 0 не считается ни положительным, ни отрицательным. Если входная последовательность пуста или равна null, следует вернуть пустой массив.

*Пример:*
```
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, -11, -12, -13, -14, -15] -> [10, -65]
```

## **Идентификация палиндромных пар слов**

 Дан список уникальных слов. Требуется найти все пары различных индексов ($i$, $j$) в данном списке, такие что конкатенация двух слов `(words[i] + words[j]`) образует палиндром.

- Нестроковые входные данные должны быть преобразованы в строки
- Пары индексов должны возвращаться в порядке их появления в исходном списке

*Примеры:*

```
["bat", "tab", "cat"]                 -> [[0, 1], [1, 0]]
["dog", "cow", "tap", "god", "pat"]   -> [[0, 3], [2, 4], [3, 0], [4, 2]]
["abcd", "dcba", "lls", "s", "sssll"] -> [[0, 1], [1, 0], [2, 4], [3, 2]]
```
## **Последовательное удаление элементов из строки**

 Дана строка и массив чисел, представляющих позиции символов для удаления. Числа указывают позиции удаляемых символов в порядке, начиная с начала массива. После каждого удаления размер строки уменьшается (пустых мест не остается). Требуется определить оставшийся символ.

 На каждом шаге удаляется символ в указанной позиции из текущего состояния строки, после чего индексы пересчитываются.

*Пример:*
*   Начальная строка: `"zbk"`, массив позиций: `[0, 1]`
*   Удаление позиции 0: `"bk"`
*   Удаление позиции 1: `"b"`
*   Результат: `'b'`

**Примечания:**
- Могут встречаться дублирующиеся буквы и числа
## **Итеративная буквенная подстановка**

 Выполнить операцию подстановки: заменить две одинаковые буквы на следующую букву алфавита (две буквы преобразуются в одну) по правилу:
- `"aa"` -> `"b"`, `"bb"` -> `"c"`, ..., `"zz"` -> `"a"`

Одинаковые буквы не обязательно должны быть соседними. Повторять операцию до тех пор, пока не останется возможных подстановок. Вернуть результирующую строку.

*Пример:*
*   Начальная строка: `"zzzab"`
*   Подстановка: `"zz"` -> `"a"`: `"azab"`
*   Подстановка: `"aa"` -> `"b"`: `"bzb"`
*   Подстановка: `"bb"` -> `"c"`: `"cz"`
*   Результат: `"cz"`

**Примечания:**
- Порядок букв в результате не важен
- Буквы `"zz"` преобразуются в `"a"`
- Входная строка содержит только строчные буквы

# Трудные задачи

## **Сумма цифр и цифровой корень**


Цифровой корень — это рекурсивная сумма всех цифр числа.

Для заданного целого неотрицательного числа `n` необходимо вычислить сумму его цифр. Если полученное значение содержит более одной цифры, процедура повторяется до тех пор, пока не будет получено однозначное число. 


```
16      -> 1 + 6 = 7  
942     -> 9 + 4 + 2 = 15 -> 1 + 5 = 6  
132189  -> 1 + 3 + 2 + 1 + 8 + 9 = 24 -> 2 + 4 = 6  
493193  -> 4 + 9 + 3 + 1 + 9 + 3 = 29 -> 2 + 9 = 11 -> 1 + 1 = 2
```



## **Подсчёт повторяющихся символов**

Напишите функцию, которая возвращает количество **различных** символов (букв латинского алфавита и цифр), встречающихся в исходной строке более одного раза. Можно предположить, что строка содержит только буквы (в верхнем и нижнем регистре) и цифры.


```
"abcde"             -> 0   ## ни один символ не повторяется  
"aabbcde"           -> 2   ## 'a' и 'b'  
"aabBcde"           -> 2   ## 'a' и 'b' (регистр игнорируется)  
"indivisibility"    -> 1   ## 'i' повторяется 6 раз  
"Indivisibilities"  -> 2   ## 'i' и 's'  
"aA11"              -> 2   ## 'a' и '1'  
"ABBA"              -> 2   ## 'A' и 'B'
```



## **Реверс слов длиной более 5 символов**

Напишите функцию, которая принимает строку из одного или нескольких слов и возвращает её, развернув все слова **длиной пять и более символов**. Строка состоит только из букв и пробелов. Пробелы присутствуют только при наличии нескольких слов.


```
"Hey fellow warriors"  -> "Hey wollef sroirraw"  
"This is a test"        -> "This is a test"  
"This is another test"  -> "This is rehtona test"
```



## **Кодирование дубликатов**

Необходимо преобразовать строку в новую строку, где каждый символ заменяется на `"("`, если он встречается в исходной строке только один раз, и на `")"`, если он встречается более одного раза. Регистр символов при определении дубликатов игнорируется.


```
"din"      -> "((("  
"recede"   -> "()()()"  
"Success"  -> ")())())"  
"(( @"     -> "))(("
```

**Примечание:** В описаниях задач может упоминаться `"XXX"` как ожидаемый результат, а не входные данные.



## **Поиск индекса с равными суммами сторон**

Дается массив целых чисел. Необходимо найти такой индекс `N`, чтобы сумма элементов слева от `N` была равна сумме элементов справа от `N`. Если такого индекса не существует, вернуть `-1`.


```
[1,2,3,4,3,2,1]         -> 3 # (левая сумма: 1+2+3=6, правая: 3+2+1=6)  
[1,100,50,-51,1,1]      -> 1 # (левая сумма: 1, правая: 50-51+1+1=1)  
[20,10,-80,10,10,15,35] -> 0 # (левая сумма: 0, правая: 10-80+10+10+15+35=0)
```


## **Сортировка слов по числу в строке**

Необходимо отсортировать слова в строке, где каждое слово содержит ровно одну цифру от 1 до 9. Цифра указывает позицию слова в результате. Если строка пуста, вернуть пустую строку.


```
"is2 Thi1s T4est 3a"               -> "Thi1s is2 3a T4est"  
"4of Fo1r pe6ople g3ood th5e the2" -> "Fo1r the2 g3ood 4of th5e pe6ople"  
""                                 -> ""
```



## **Устойчивость числа**

Напишите функцию `persistence`, которая для положительного целого числа `num` возвращает его мультипликативную персистентность — количество шагов, за которые число преобразуется в однозначное в результате перемножения его цифр.


```
39  -> 3  # 3*9=27 -> 2*7=14 -> 1*4=4
999 -> 4  # 9*9*9=729 -> 7*2*9=126 -> 1*2*6=12 -> 1*2=2  
4   -> 0  # число уже однозначное
```



## **Система лайков**

Реализуйте функцию, которая принимает массив имён и возвращает строку в формате, аналогичном системе лайков в социальных сетях.


```
[] -> "no one likes this"  
["Peter"] -> "Peter likes this"  
["Jacob", "Alex"] -> "Jacob and Alex like this"  
["Max", "John", "Mark"] -> "Max, John and Mark like this"  
["Alex", "Jacob", "Mark", "Max"] -> "Alex, Jacob and 2 others like this"
```

Для 4 и более имён используется шаблон `"and X others"`.


## **Проверка маршрута прогулки**

Город Картезия имеет идеальную сетку улиц. Вы всегда проходите 1 блок за 1 минуту. Функция должна вернуть `true`, если предложенный маршрут:
- Занимает ровно 10 минут.
- Возвращает вас в начальную точку.

**Примечание:** Маршрут состоит из символов `'n'`, `'s'`, `'e'`, `'w'`. Массив не пуст.

**Примеры тестов:**
```
is_valid_walk(['n','s','n','s','n','s','n','s','n','s']) -> True  
is_valid_walk(['w','e','w','e','w','e','w','e','w','e','w','e']) -> False  
is_valid_walk(['w']) -> False  
is_valid_walk(['n','n','n','s','n','s','n','s','n','s']) -> False
```


## **Уникальные элементы с сохранением порядка**

Реализуйте функцию `unique_in_order`, которая принимает последовательность и возвращает список элементов, удалив повторяющиеся подряд элементы, сохранив исходный порядок.


```
"AAAABBBCCDAABBB" -> ['A','B','C','D','A','B']  
"ABBCcAD" -> ['A','B','C','c','A','D']  
[1,2,2,3,3] -> [1,2,3]
```

