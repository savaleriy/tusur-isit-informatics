
# 0. Сравнение времени работы алгоритмов

Напишите функцию `complexity_table(sizes)`, которая принимает список размеров данных и выводит таблицу, показывающую рост количества операций для различных асимптотических сложностей.


1. **Функция должна принимать один параметр:**
   - `sizes` - список целых чисел (размеры входных данных)

2. **Функция должна выводить таблицу со следующими колонками:**
   - n (размер данных)
   - O(1) - константная сложность
   - O(log n) - логарифмическая сложность  
   - O(√n) - квадратный корень
   - O(n) - линейная сложность
   - O(n log n) - линейно-логарифмическая сложность
   - O(n²) - квадратичная сложность
   - O(n³) - кубическая сложность
   - O(2ⁿ) - экспоненциальная сложность
   - O(n!) - факториальная сложность


```python
# Тестирование функции
sizes = [1, 10, 100, 1000, 10000]
complexity_table(sizes)
```

**Ожидаемый вывод:**
```
Рост количества операций для разных O-сложностей:
n       O(1)    O(log n)    O(sqrt(n))     O(n)    O(n log n)    O(n**2)       O(n**3)       O(2**n)       O(n!)
------------------------------------------------------------------------------------------------------
1       1       0.00        1.00      1       0.00          1           1           2           1
10      1       3.32        3.16      10      33.22         100         1000        1024        3628800
100     1       6.64        10.00     100     664.39        10000       1000000     1.27e+30    
1000    1       9.97        31.62     1000    9965.78       1000000     1.00e+9      
10000   1       13.29       100.00    10000   132877.12     100000000   1.00e+12     
```

# 1. Анаграммы 

Вам нужно реализовать **четыре алгоритма** для определения, являются ли две строки анаграммами. Эти методы обсуждались на практическом занятии:

1. **Проверка вхождения (Метки)** — $O(n^2)$
2. **Сортировка и сравнение** — $O(n \log n)$
3. **Метод полного перебора** — $O(n!)$
4. **Подсчёт и сравнение символов** — $O(n)$

Для тестирования вы будете использовать словарь из файла `data/words.csv`, содержащий около 58 000 английских слов.


Шаблоны для функций:

```python
def is_anagram_method1(s1, s2):
    """
    Метод 1: Проверка вхождения (Метки)
    Идея: для каждого символа из s1 ищем совпадение в s2 и "помечаем" его.
    """
    # Ваш код здесь
    pass


def is_anagram_method2(s1, s2):
    """
    Метод 2: Сортировка и сравнение
    Идея: отсортировать обе строки и сравнить результаты.
    """
    # Ваш код здесь
    pass


def is_anagram_method3(s1, s2):
    """
    Метод 3: Полный перебор (brute force)
    Идея: сгенерировать все перестановки s1 и проверить, есть ли среди них s2.
    Внимание: этот метод крайне медленный — используйте только для коротких слов (длина ≤ 7).
    """
    # Ваш код здесь
    pass


def is_anagram_method4(s1, s2):
    """
    Метод 4: Подсчёт частот символов
    Идея: подсчитать, сколько раз встречается каждая буква в обеих строках, и сравнить счётчики.
    Предполагается, что слова содержат только строчные латинские буквы.
    """
    # Ваш код здесь
    pass
```

Напишите функцию, которая:

1. Выбирает **случайное слово** из `dictionary`.
2. Находит **все слова в словаре**, которые являются его анаграммами (исключая само слово).
3. Использует **один из ваших методов** (например, метод 4 — самый быстрый).

```python
import random

def find_anagrams_for_random_word(method_func):
    word = random.choice(dictionary)
    print(f"Исходное слово: {word}")
    
    anagrams = []
    for candidate in dictionary:
        if candidate != word and method_func(word, candidate):
            anagrams.append(candidate)
    
    print(f"Найдено анаграмм: {len(anagrams)}")
    print("Примеры:", anagrams[:10])
    return anagrams
    

find_anagrams_for_random_word(is_anagram_method1)
find_anagrams_for_random_word(is_anagram_method2)
find_anagrams_for_random_word(is_anagram_method3)
find_anagrams_for_random_word(is_anagram_method4)
```
# 2. Сортировка колоды карт

Вы — раздающий на турнире по карточным играм, и ваша задача — отсортировать колоду карт. Колода состоит из карт с различными значениями, и вы хотите использовать алгоритм быстрой сортировки для упрощения процесса.

- Если в колоде менее четырех карт, вы должны просто упорядочить их и завершить работу.
- Если в колоде четыре или более карт:
    - Выберите наугад одну карту, которая будет служить опорной.
    - Разделите оставшиеся карты на две группы:
        - **Левая колода**: карты с меньшим значением, чем у опорной.
        - **Правая колода**: карты с большим значением.
- Проделайте ту же процедуру для каждой из новых колод.
- Объедините отсортированные левые карты, опорную карту и отсортированные правые карты, чтобы получить окончательную отсортированную колоду.

```python
import random # Using for  random.choice(deck) 

def quick_sort_deck(deck):
	pass

# Пример использования
deck = [4, 2, 7, 1, 3, 5]
sorted_deck = quick_sort_deck(deck)
print(sorted_deck)  # Ожидаемый вывод: [1, 2, 3, 4, 5, 7]
# Тест 1
assert quick_sort_deck([4, 2, 7, 1, 3, 5]) == [1, 2, 3, 4, 5, 7]
# Тест 2
assert quick_sort_deck([10, 5, 3, 8]) == [3, 5, 8, 10]
# Тест 3
assert quick_sort_deck([1]) == [1]
# Тест 4
assert quick_sort_deck([3, 2]) == [2, 3]
# Тест 5
assert quick_sort_deck([7, 3, 3, 4, 1, 2, 5]) == [1, 2, 3, 3, 4, 5, 7]
print("OK!")
```

# 3. Линейный поиск

Вам необходимо разработать функцию, которая будет искать элемент в списке чисел. Для этого вы решили использовать метод линейного поиска. Это простой алгоритм, который последовательно проверяет каждый элемент списка, пока не найдет искомый.

- Алгоритм линейного поиска проходит по каждому элементу списка.
- Если элемент найден, функция должна вернуть его индекс.
- Если элемент не найден, функция должна вернуть `-1`.

```python
def linear_search(arr, target):


# Тест 1
assert linear_search([5, 3, 7, 1, 4], 1) == 3
# Тест 2
assert linear_search([10, 20, 30, 40], 30) == 2
# Тест 3
assert linear_search([1, 2, 3, 4], 5) == -1
# Тест 4
assert linear_search([1], 1) == 0
# Тест 5
assert linear_search([], 1) == -1
print("OK!")

```

# 4. Бинарный поиск

Вам необходимо разработать функцию, которая будет искать элемент в отсортированном списке чисел. Для этого вы решили использовать метод бинарного поиска. Этот алгоритм позволяет эффективно находить элемент, деля список на две части.

- Алгоритм бинарного поиска работает только с отсортированными массивами.
- Он начинается с нахождения среднего элемента:
    - Если средний элемент равен искомому, возвращаем его индекс.
    - Если искомый элемент меньше среднего, продолжаем поиск в левой половине.
    - Если искомый элемент больше среднего, продолжаем поиск в правой половине.
- Если элемент не найден, функция должна вернуть `-1`.

```python
def binary_search(arr, target):
	pass

# Пример использования
sorted_numbers = [1, 2, 3, 4, 5, 6, 7]
index_of_four = binary_search(sorted_numbers, 4)
print(index_of_four)  # Ожидаемый вывод: 3

index_of_eight = binary_search(sorted_numbers, 8)
print(index_of_eight)  # Ожидаемый вывод: -1
# Тест 1
assert binary_search([1, 2, 3, 4, 5, 6, 7], 4) == 3
# Тест 2
assert binary_search([1, 2, 3, 4, 5, 6, 7], 6) == 5
# Тест 3
assert binary_search([1, 2, 3, 4, 5, 6, 7], 1) == 0
# Тест 4
assert binary_search([1, 2, 3, 4, 5, 6, 7], 8) == -1
# Тест 5
assert binary_search([], 1) == -1  # Пустой массив
print("Все тесты пройдены!")

```


# 5. Частые значения 
Вам дана последовательность из n целых чисел ($a_1, a_2, \ldots, a_n$) в неубывающем порядке. Кроме того, вам дается несколько запросов, состоящих из индексов ($i$) и ($j$) (($1 \leq i \leq j \leq n$)). Для каждого запроса определите наиболее частое значение среди целых чисел ($a_i, \ldots, a_j$).


Входные данные состоят из нескольких тестовых примеров. Каждый тестовый пример начинается со строки, содержащей два целых числа ($n$) и ($q$) $(1 \leq n, q \leq 100000)$. Следующая строка содержит ($n$) целых чисел ($a_1, \ldots, a_n$) (($-100000 \leq a_i \leq 100000$), для каждого ($i \in {1, \ldots, n }$)) разделенные пробелами. Можно предположить, что для каждого ($i \in {1, \ldots, n-1}), (a_i \leq a_{i+1}$). Следующие строки ($q$) содержат по одному запросу, состоящему из двух целых чисел ($i$) и ($j$) ($(1 \leq i \leq j \leq n$)), обозначающих индексы границ. для запроса. За последним тестовым примером следует строка, содержащая один «0».

```
10 3
-1 -1 1 1 1 1 3 10 10 10
2 3
1 10
5 10
0
```


Для каждого запроса выведите одну строку с одним целым числом: количество вхождений наиболее частого значения в заданном диапазоне.

```
1
4
3
```

```python
def most_frequent_value_count(n, q, array, queries):
    # Ваша реализация здесь
    pass

def test_most_frequent_value_count():
    # Тест 1
    n1, q1 = 10, 3
    array1 = [-1, -1, 1, 1, 1, 1, 3, 10, 10, 10]
    queries1 = [(2, 3), (1, 10), (5, 10)]
    expected1 = [1, 4, 3]
    assert most_frequent_value_count(n1, q1, array1, queries1) == expected1

    # Тест 2
    n2, q2 = 5, 2
    array2 = [1, 1, 2, 2, 2]
    queries2 = [(1, 5), (2, 4)]
    expected2 = [5, 3]
    assert most_frequent_value_count(n2, q2, array2, queries2) == expected2

    # Тест 3
    n3, q3 = 6, 3
    array3 = [3, 3, 4, 4, 4, 5]
    queries3 = [(1, 2), (1, 6), (3, 6)]
    expected3 = [2, 4, 3]
    assert most_frequent_value_count(n3, q3, array3, queries3) == expected3

    # Тест 4
    n4, q4 = 1, 1
    array4 = [7]
    queries4 = [(1, 1)]
    expected4 = [1]
    assert most_frequent_value_count(n4, q4, array4, queries4) == expected4

    # Тест 5
    n5, q5 = 7, 3
    array5 = [1, 2, 2, 3, 3, 3, 4]
    queries5 = [(1, 7), (2, 5), (3, 7)]
    expected5 = [3, 3, 3]
    assert most_frequent_value_count(n5, q5, array5, queries5) == expected5

    # Тест 6: Пустой массив
    n6, q6 = 0, 0
    array6 = []
    queries6 = []
    expected6 = []
    assert most_frequent_value_count(n6, q6, array6, queries6) == expected6

    print(OK!")
test_most_frequent_value_count()
```
# 6. Причудливые квадраты

У числа 3025 есть замечательная особенность: если разделить его десятичное представление на две строки равных длин (30 и 25) и возведите в квадрат сумму полученных таким образом чисел, вы получите исходное число: $(30 + 25)^2 = 3025$

Задача состоит в том, чтобы определить все числа с этим свойством, имеющие заданное четное количество цифр. Например, четырехзначные числа имеют диапазон от 0000 до 9999. Обратите внимание, что ведущие нули следует брать в учетную запись.  Это означает, что $0001$ равно $(00 + 01)^2$  и это причудливое число из 4 цифр. Количество цифр может быть 2,4,6 или 8. Однако стоит задуматься об эффективности 

$$N = a_1 a_2 \ldots a_k a_{k+1} a_{k+2} \ldots a_{2k} $$
$$L = a_1 a_2 \ldots a_k $$
$$R = a_{k+1} a_{k+2} \ldots a_{2k} $$
$$(L + R)^2 = N$$

- $N$ — число с $2k$ цифрами.
- $L$ — левая часть из первых $k$ цифр.
- $R$ — правая часть из последних $k$ цифр.
- Условие, при котором число $N$ считается "причудливым".
 Входные данные 
```
2
```
 Выходные данные
```
00 
01 
81 
```

```python
def find_quirky_numbers(digit_count): 
	return
	
# Тесты
def test_find_quirky_numbers():
    # Тест 1
    digit_count = 2
    expected_output = ['00', '01', '81']
    assert find_quirky_numbers(digit_count) == expected_output

    # Тест 2
    digit_count = 4
    expected_output = ['0000', '0001', '0004', '0009', '0016', '0025', 
                      '0040', '0081', '0096', '0160', '0250', '0400', 
                      '0640', '0810', '1000', '1024', '1600', '2025', 
                      '2500', '3025', '3600', '4000', '6400', '8100', 
                      '9600']
    assert find_quirky_numbers(digit_count) == expected_output

    # Тест 3
    digit_count = 6
    expected_output = []  # Не ожидается никаких "причудливых" чисел
    assert find_quirky_numbers(digit_count) == expected_output

    # Тест 4
    digit_count = 8
    expected_output = []  # Не ожидается никаких "причудливых" чисел
    assert find_quirky_numbers(digit_count) == expected_output

    print("OK!")

# Запустите тесты
test_find_quirky_numbers()
```
# 7. Шахматы

Почти всем знакома классическая задача: разместить восемь ферзей на шахматной доске 8х8 так, чтобы ни один ферзь не мог захватить другого. Ян Тимман, известный голландский шахматист, теперь заинтересован в определении максимального количества шахматных фигур. одного типа, который можно разместить на доске m × n заданного размера, гарантируя, что ни одна фигура не сможет захватить другую. Учитывая сложность поиска решения вручную, он обращается к вам за помощью в решении этой задачи.

Тиммана интересуют только конкретные шахматные фигуры. Пешки считаются неинтересными, а слоны ему не особенно нравятся. Его внимание сосредоточено на понимании максимального количества ладей, коней, ферзей или королей, которые можно разместить на доске, гарантируя, что каждая фигура не сможет захватить любую другую.

Вход:
Первая строка ввода указывает количество проблем. Каждая последующая строка представляет собой задачу и состоит из одного символа из набора {'r', 'k', 'Q', 'K'}, соответствующего шахматным фигурам: ладье, коню, ферзю или королю. За символом следуют два целых числа: m (4 ≤ m ≤ 10) и n (4 ≤ n ≤ 10), обозначающие количество строк и столбцов на доске.

Выход:
Для каждой задачи, указанной во входных данных, ваша программа должна вывести максимальное количество шахматных фигур, которые можно разместить на доске заданных размеров, гарантируя, что ни одна фигура не сможет захватить любую другую.

Примечание:
Левый нижний квадрат обозначен как (1, 1).

```
Sample Input 
2 
r 6 7
k 8 8 
Sample Output 
6 
32
```

```python
def max_chesspieces(problem_count, problems):
    """
    """
    # Your implementation goes here
    pass

# Example usage:
problem_count = 2
problems = [('r', 4, 4), ('Q', 8, 8)]
result = max_chesspieces(problem_count, problems)
print(result)
```

## 8. Взаимные циклы

Единичная дробь содержит $1$ в числителе. Дано десятичное представление единичных дробей со знаменателями от $2$ до $10$:

$$1/2  = 0,5$$
$$1/3 = 0.(3)$$
$$1/4  = 0,25$$
$$1/5  = 0,2$$
$$1/6 = 0,1(6)$$
$$1/7  = 0.(142857)$$
$$1/8  = 0,125$$
$$1/9  = 0.(1)$$
$$1/10  = 0,1$$

Где $0.1(6)$ означает $(0.166666$) и имеет **(1)-значный повторяющийся цикл**. Видно, что ($1/7$) имеет **(6)-значный повторяющийся цикл**.

Найдите значение ($d \lt 1000$), для которого ($1/d$) содержит **самый длинный повторяющийся цикл в своей десятичной дробной части**

## 9. Делимость подстроки

Число $1406357289$ является **панцифровым** числом от $0$ до $9$, поскольку оно состоит из каждой цифры от $0$ до $9$ в определенном порядке, но оно также обладает довольно интересным свойством делимости на подстроки.

Пусть $d_1$ — $1^{st}$ цифра, $d_2$ — $2^{nd}$ цифра и т. д. Таким образом, отметим следующее:

- $d_2d_3d_4=406$ делится на $2$
- $d_3d_4d_5=063$ делится на $3$
- $d_4d_5d_6=635$ делится на $5$
- $d_5d_6d_7=357$ делится на $7$
- $d_6d_7d_8=572$ делится на $11$
- $d_7d_8d_9=728$ делится на $13$
- $d_8d_9d_{10}=289$ делится на $17$

Найдите сумму всех **панцифровых** чисел от $0$ до $9$ с этим свойством.

